var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate
});
var import_path = __toModule(require("path"));
var import_coc2 = __toModule(require("coc.nvim"));

// src/schema-extension-api.ts
var import_coc = __toModule(require("coc.nvim"));
var MODIFICATION_ACTIONS;
(function(MODIFICATION_ACTIONS2) {
  MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["delete"] = 0] = "delete";
  MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["add"] = 1] = "add";
})(MODIFICATION_ACTIONS || (MODIFICATION_ACTIONS = {}));
var SchemaModificationNotification;
(function(SchemaModificationNotification2) {
  SchemaModificationNotification2.type = new import_coc.RequestType("json/schema/modify");
})(SchemaModificationNotification || (SchemaModificationNotification = {}));
var SchemaExtensionAPI = class {
  constructor(client2) {
    this._customSchemaContributors = {};
    this._yamlClient = client2;
  }
  registerContributor(schema, requestSchema, requestSchemaContent, label) {
    if (this._customSchemaContributors[schema]) {
      return false;
    }
    if (!requestSchema) {
      throw new Error("Illegal parameter for requestSchema.");
    }
    if (label) {
      const [first, second] = label.split(":");
      if (first && second) {
        label = second.trim();
        label = label.replace(".", "\\.");
        label = `${first}:[	 ]+${label}`;
      }
    }
    this._customSchemaContributors[schema] = {
      requestSchema,
      requestSchemaContent,
      label
    };
    return true;
  }
  requestCustomSchema(resource) {
    const matches = [];
    for (const customKey of Object.keys(this._customSchemaContributors)) {
      try {
        const contributor = this._customSchemaContributors[customKey];
        let uri;
        if (contributor.label && import_coc.workspace.textDocuments) {
          const labelRegexp = new RegExp(contributor.label, "g");
          for (const doc of import_coc.workspace.textDocuments) {
            if (doc.uri.toString() === resource) {
              if (labelRegexp.test(doc.getText())) {
                uri = contributor.requestSchema(resource);
                return [uri];
              }
            }
          }
        }
        uri = contributor.requestSchema(resource);
        if (uri) {
          matches.push(uri);
        }
      } catch (error) {
        this._yamlClient.outputChannel.appendLine(`Error thrown while requesting schema "${error}" when calling the registered contributor "${customKey}"`);
      }
    }
    return matches;
  }
  requestCustomSchemaContent(uri) {
    if (uri) {
      const _uri = import_coc.Uri.parse(uri);
      if (_uri.scheme && this._customSchemaContributors[_uri.scheme] && this._customSchemaContributors[_uri.scheme].requestSchemaContent) {
        return this._customSchemaContributors[_uri.scheme].requestSchemaContent(uri);
      }
    }
  }
  async modifySchemaContent(schemaModifications) {
    return this._yamlClient.sendRequest(SchemaModificationNotification.type, schemaModifications);
  }
};
var CUSTOM_SCHEMA_REQUEST = "custom/schema/request";
var CUSTOM_CONTENT_REQUEST = "custom/schema/content";

// src/paths.ts
var Dot = ".".charCodeAt(0);
function normalizePath(parts) {
  const newParts = [];
  for (const part of parts) {
    if (part.length === 0 || part.length === 1 && part.charCodeAt(0) === Dot) {
    } else if (part.length === 2 && part.charCodeAt(0) === Dot && part.charCodeAt(1) === Dot) {
      newParts.pop();
    } else {
      newParts.push(part);
    }
  }
  if (parts.length > 1 && parts[parts.length - 1].length === 0) {
    newParts.push("");
  }
  let res = newParts.join("/");
  if (parts[0].length === 0) {
    res = "/" + res;
  }
  return res;
}
function joinPath(uri, ...paths) {
  const parts = uri.path.split("/");
  for (const path2 of paths) {
    parts.push(...path2.split("/"));
  }
  return uri.with({path: normalizePath(parts)});
}

// src/index.ts
var SchemaAssociationNotification;
(function(SchemaAssociationNotification2) {
  SchemaAssociationNotification2.type = new import_coc2.NotificationType("json/schemaAssociations");
})(SchemaAssociationNotification || (SchemaAssociationNotification = {}));
var VSCodeContentRequestRegistration;
(function(VSCodeContentRequestRegistration2) {
  VSCodeContentRequestRegistration2.type = new import_coc2.NotificationType("yaml/registerVSCodeContentRequest");
})(VSCodeContentRequestRegistration || (VSCodeContentRequestRegistration = {}));
var VSCodeContentRequest;
(function(VSCodeContentRequest2) {
  VSCodeContentRequest2.type = new import_coc2.RequestType("vscode/content");
})(VSCodeContentRequest || (VSCodeContentRequest = {}));
var DynamicCustomSchemaRequestRegistration;
(function(DynamicCustomSchemaRequestRegistration2) {
  DynamicCustomSchemaRequestRegistration2.type = new import_coc2.NotificationType("yaml/registerCustomSchemaRequest");
})(DynamicCustomSchemaRequestRegistration || (DynamicCustomSchemaRequestRegistration = {}));
var client;
function activate(context) {
  const serverModule = context.asAbsolutePath(import_path.default.join("node_modules", "yaml-language-server", "out", "server", "src", "server.js"));
  const debugOptions = {execArgv: ["--nolazy", "--inspect=6009"]};
  const serverOptions = {
    run: {module: serverModule, transport: import_coc2.TransportKind.ipc},
    debug: {module: serverModule, transport: import_coc2.TransportKind.ipc, options: debugOptions}
  };
  const clientOptions = {
    documentSelector: [{language: "yaml"}],
    synchronize: {
      fileEvents: [import_coc2.workspace.createFileSystemWatcher("**/*.?(e)y?(a)ml"), import_coc2.workspace.createFileSystemWatcher("**/*.json")]
    }
  };
  client = new import_coc2.LanguageClient("yaml", "YAML Support", serverOptions, clientOptions);
  const disposable = client.start();
  const schemaExtensionAPI = new SchemaExtensionAPI(client);
  context.subscriptions.push(disposable);
  client.onReady().then(() => {
    client.sendNotification(SchemaAssociationNotification.type, getSchemaAssociations());
    import_coc2.extensions.onDidActiveExtension(() => {
      client.sendNotification(SchemaAssociationNotification.type, getSchemaAssociations());
    });
    import_coc2.extensions.onDidUnloadExtension(() => {
      client.sendNotification(SchemaAssociationNotification.type, getSchemaAssociations());
    });
    client.sendNotification(DynamicCustomSchemaRequestRegistration.type);
    client.sendNotification(VSCodeContentRequestRegistration.type);
    client.onRequest(CUSTOM_SCHEMA_REQUEST, (resource) => {
      return schemaExtensionAPI.requestCustomSchema(resource);
    });
    client.onRequest(CUSTOM_CONTENT_REQUEST, (uri) => {
      return schemaExtensionAPI.requestCustomSchemaContent(uri);
    });
    client.onRequest(VSCodeContentRequest.type, (uri) => {
      return import_coc2.fetch(uri, {
        headers: {"Accept-Encoding": "gzip, deflate"}
      }).then((res) => {
        if (typeof res === "string")
          return res;
        if (Buffer.isBuffer(res))
          return res.toString();
        return JSON.stringify(res);
      }, (err) => {
        return Promise.reject(err);
      });
    });
  });
  return schemaExtensionAPI;
}
function getSchemaAssociations() {
  const associations = [];
  import_coc2.extensions.all.forEach((extension) => {
    const packageJSON = extension.packageJSON;
    if (packageJSON && packageJSON.contributes && packageJSON.contributes.yamlValidation) {
      const yamlValidation = packageJSON.contributes.yamlValidation;
      if (Array.isArray(yamlValidation)) {
        yamlValidation.forEach((jv) => {
          let {fileMatch, url} = jv;
          if (typeof fileMatch === "string") {
            fileMatch = [fileMatch];
          }
          if (Array.isArray(fileMatch) && typeof url === "string") {
            let uri = url;
            if (uri[0] === "." && uri[1] === "/") {
              uri = joinPath(import_coc2.Uri.file(extension.extensionPath), uri).toString();
            }
            fileMatch = fileMatch.map((fm) => {
              if (fm[0] === "%") {
                fm = fm.replace(/%APP_SETTINGS_HOME%/, "/User");
                fm = fm.replace(/%MACHINE_SETTINGS_HOME%/, "/Machine");
                fm = fm.replace(/%APP_WORKSPACES_HOME%/, "/Workspaces");
              } else if (!fm.match(/^(\w+:\/\/|\/|!)/)) {
                fm = "/" + fm;
              }
              return fm;
            });
            associations.push({fileMatch, uri});
          }
        });
      }
    }
  });
  return associations;
}
//# sourceMappingURL=index.js.map
