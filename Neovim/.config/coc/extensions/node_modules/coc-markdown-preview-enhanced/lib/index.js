var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module3, copyDefault, desc) => {
  if (module3 && typeof module3 === "object" || typeof module3 === "function") {
    for (let key of __getOwnPropNames(module3))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module3[key], enumerable: !(desc = __getOwnPropDesc(module3, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module3, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module3 != null ? __create(__getProtoOf(module3)) : {}, "default", !isNodeMode && module3 && module3.__esModule ? { get: () => module3.default, enumerable: true } : { value: module3, enumerable: true })), module3);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module3, temp) => {
    return cache && cache.get(module3) || (temp = __reExport(__markAsModule({}), module3, 1), cache && cache.set(module3, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
var import_mume3 = require("@shd101wyy/mume");
var import_coc19 = require("coc.nvim");
var import_path2 = __toESM(require("path"));
var import_url = require("url");

// src/image-helper.ts
var import_mume = require("@shd101wyy/mume");
var import_coc16 = require("coc.nvim");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));

// node_modules/coc-helper/lib/esm/index.js
var import_coc14 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/events.js
var import_coc7 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/VimModule.js
var import_coc5 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/notifier.js
var import_coc4 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/util/collection.js
var compactI = (arr) => arr.filter((it) => it !== void 0 && it !== null);

// node_modules/coc-helper/lib/esm/util/config.js
var import_coc2 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/util/text.js
var import_coc = require("coc.nvim");

// node_modules/coc-helper/lib/esm/util/env.js
var isWindows = process.platform === "win32";
var isMacintosh = process.platform === "darwin";
var isLinux = process.platform === "linux";
var isTest = process.env.NODE_ENV === "test";

// node_modules/coc-helper/lib/esm/util/text.js
async function displayWidth(content) {
  return await import_coc.workspace.nvim.call("strdisplaywidth", [content]);
}

// node_modules/coc-helper/lib/esm/util/log.js
var import_coc3 = require("coc.nvim");
var import_util = __toESM(require("util"));
var levelList = [
  "trace",
  "debug",
  "info",
  "warn",
  "error",
  "fatal",
  "off"
];
var levelErrorNum = levelList.indexOf("error");
function formatDate(date) {
  return `${date.toLocaleString()} ${date.getMilliseconds().toString().padStart(3, "0")}`;
}
var HelperLogger = class {
  constructor(channelName) {
    this.channelName = channelName;
    this.timeMarkers = /* @__PURE__ */ new Map();
    this.levelStatus = "trace";
    this.levelNumber = levelList.indexOf(this.levelStatus);
    this.appendLine = (line) => {
      this.outputChannel.appendLine(line);
    };
    this.log = (levelName, data) => {
      var _a, _b;
      const levelNum = levelList[levelName];
      if (levelNum < this.levelNumber) {
        return;
      }
      const prefix = `[${formatDate(new Date())}] [${levelName}]: `;
      if (data instanceof Error) {
        this.appendLine(`${prefix}${(_a = data.stack) !== null && _a !== void 0 ? _a : data.toString()}`);
        import_coc3.window.showMessage(data.message, "error");
        if (isTest) {
          console.error((_b = data.stack) !== null && _b !== void 0 ? _b : data.toString());
        }
        return;
      }
      this.appendLine(`${prefix}${data}`);
      if (levelNum > levelErrorNum) {
        import_coc3.window.showMessage(data, "error");
        if (isTest) {
          console.error(data);
        }
      }
    };
    this.trace = (line) => {
      this.log("trace", line);
    };
    this.debug = (line) => {
      this.log("debug", line);
    };
    this.info = (line) => {
      this.log("info", line);
    };
    this.warn = (line) => {
      this.log("warn", line);
    };
    this.error = (data) => {
      if (!(data instanceof Error)) {
        data = new Error(data);
      }
      this.log("error", data);
    };
    this.fatal = (data) => {
      this.log("fatal", data);
    };
  }
  set level(level) {
    this.levelStatus = level;
    this.levelNumber = levelList[level];
  }
  get level() {
    return this.levelStatus;
  }
  dispose() {
    var _a;
    (_a = this.outputChannel_) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  get outputChannel() {
    if (!this.outputChannel_) {
      this.outputChannel_ = import_coc3.window.createOutputChannel(this.channelName);
    }
    return this.outputChannel_;
  }
  time(label = "default") {
    this.timeMarkers.set(label, new Date().valueOf());
  }
  timeElapsed(label = "default") {
    const time = this.timeMarkers.get(label);
    if (time !== void 0) {
      return new Date().valueOf() - time;
    }
  }
  timeLog(label = "default") {
    const time = this.timeElapsed(label);
    if (time !== void 0) {
      this.appendLine(`${label}: ${time} ms`);
    }
  }
  measureTime(task) {
    const time = new Date().valueOf();
    const result = task();
    if (!("then" in result)) {
      return [result, new Date().valueOf() - time];
    }
    return result.then((r) => {
      return [r, new Date().valueOf() - time];
    });
  }
  measureTask(task, label = "default", level = "info") {
    const response = this.measureTime(task);
    if (!("then" in response)) {
      const [result, time] = response;
      this.log(level, `[measureTask] ${label}: ${time} ms`);
      return result;
    }
    return response.then(([result, time]) => {
      this.log(level, `${label}: ${time} ms`);
      return result;
    });
  }
  asyncCatch(fn) {
    return async (...args) => {
      try {
        return await fn(...args);
      } catch (e) {
        this.error(e);
      }
    };
  }
  prettyPrint(...data) {
    this.info(prettyObject(...data));
    import_coc3.window.showMessage(`[${formatDate(new Date())}] ${prettyObject(...data)}`);
  }
};
var helperLogger = new HelperLogger("coc-helper");
function prettyObject(...data) {
  return data.map((d) => import_util.default.inspect(d)).join(" ");
}

// node_modules/coc-helper/lib/esm/_package.json
var name = "coc-helper";
var version = "0.12.1";
var description = "Helpers for coc.nvim";
var module2 = "lib/esm/index.js";
var main = "lib/cjs/index.js";
var homepage = "https://github.com/weirongxu/coc-helper";
var repository = "git@github.com:weirongxu/coc-helper.git";
var author = "Weirong Xu <weirongxu.raidou@gmail.com>";
var license = "MIT";
var files = [
  "lib",
  "tests",
  "jest.config.js",
  "JestHelper.js",
  "JestHelper.d.ts"
];
var scripts = {
  clean: "rimraf lib",
  "copy:pkg": "cpy --rename=_package.json package.json src/",
  "build:esm": "tsc -p ./tsconfig.prod.json --module es2020 --outDir lib/esm",
  "build:cjs": "tsc -p ./tsconfig.prod.json --module commonjs --outDir lib/cjs",
  build: "npm-run-all clean copy:pkg build:esm build:cjs",
  lint: "eslint src --ext ts",
  "setup:test-env": "node ./tests/setup.js",
  prepare: "run-s clean setup:test-env build",
  unittest: "jest --runInBand --detectOpenHandles --forceExit",
  test: "npm-run-all copy:pkg lint unittest"
};
var engines = {
  coc: "^0.0.77"
};
var activationEvents = [
  "*"
];
var prettier = {
  singleQuote: true,
  printWidth: 80,
  semi: true,
  trailingComma: "all"
};
var peerDependencies = {
  "coc.nvim": "*"
};
var devDependencies = {
  "@chemzqm/neovim": "^5.4.0",
  "@types/eslint": "^7.28.0",
  "@types/jest": "^27.0.1",
  "@types/node": "^16.9.1",
  "@types/rimraf": "^3.0.2",
  "@types/uuid": "^8.3.1",
  "@typescript-eslint/eslint-plugin": "^4.31.1",
  "@typescript-eslint/parser": "^4.31.1",
  "coc.nvim": "0.0.81-next.0",
  "cpy-cli": "^3.1.1",
  eslint: "^7.32.0",
  jest: "^27.2.0",
  log4js: "^6.3.0",
  "npm-run-all": "^4.1.5",
  "ts-jest": "^27.0.5",
  "type-fest": "^2.3.2",
  typescript: "^4.4.3"
};
var dependencies = {
  rimraf: "^3.0.2",
  uuid: "^8.3.2"
};
var package_default = {
  name,
  version,
  description,
  module: module2,
  main,
  homepage,
  repository,
  author,
  license,
  files,
  scripts,
  engines,
  activationEvents,
  prettier,
  peerDependencies,
  devDependencies,
  dependencies
};

// node_modules/coc-helper/lib/esm/util/version.js
var version2 = package_default.version;
var versionName = version2.replace(/[.-]/g, "_");

// node_modules/coc-helper/lib/esm/notifier.js
var Notifier = class {
  constructor(notify) {
    this.notifyFns = [];
    this.notifyFns.push(notify);
  }
  static async run(notifier) {
    if (!notifier) {
      return;
    }
    if ("then" in notifier) {
      const awaitedNotifier = await notifier;
      if (awaitedNotifier) {
        return awaitedNotifier.run();
      }
    } else {
      return notifier.run();
    }
  }
  static notifyAll(lazyNotifies) {
    for (const n of lazyNotifies) {
      if (n) {
        n.notify();
      }
    }
  }
  static async runAll(notifierPromises) {
    const notifiers = await Promise.all(notifierPromises);
    import_coc4.workspace.nvim.pauseNotification();
    this.notifyAll(notifiers);
    return import_coc4.workspace.nvim.resumeNotification();
  }
  static combine(notifiers) {
    const compactedNotifiers = compactI(notifiers);
    if (compactedNotifiers.length < 1) {
      return Notifier.noop();
    }
    if (compactedNotifiers.length === 1) {
      return compactedNotifiers[0];
    }
    return compactedNotifiers.reduce((ret, cur) => ret.concat(cur), Notifier.noop());
  }
  static noop() {
    return this.create(() => {
    });
  }
  static create(notify) {
    return new Notifier(notify);
  }
  async run() {
    return Notifier.runAll([this]);
  }
  notify() {
    for (const fn of this.notifyFns) {
      fn();
    }
  }
  concat(notifier) {
    this.notifyFns.push(...notifier.notifyFns);
    return this;
  }
};

// node_modules/coc-helper/lib/esm/util/module.js
var globalModuleIdKey = "__coc_helper_module_max_id";
function getModuleId(key) {
  const globalKey2 = `${globalModuleIdKey}_${key}`;
  if (!(globalKey2 in global)) {
    global[globalKey2] = 0;
  }
  global[globalKey2] += 1;
  return global[globalKey2];
}

// node_modules/coc-helper/lib/esm/VimModule.js
var mid = getModuleId("VimModule");
var globalKey = `coc_helper_module_m${mid}_v${versionName}`;
var globalVariable = `g:${globalKey}`;
var callFunc = `CocHelperCallFn_m${mid}_v${versionName}`;
var declareVar = `CocHelperCallVar_m${mid}_v${versionName}`;
function filterLineCont(content) {
  return content.replace(/\n\s*\\/g, "");
}
var VimModule = class {
  constructor(moduleKey) {
    this.moduleKey = moduleKey;
  }
  static async init(context) {
    this.inited = true;
    await import_coc5.workspace.nvim.call("execute", `
        if !exists('${globalVariable}')
          let ${globalVariable} = {}
        endif

        function! ${callFunc}(module_key, method_name, args)
          try
            return call(${globalVariable}[a:module_key][a:method_name], a:args)
          catch
            let ex = v:exception
            let msg = printf('error when call %s.%s.%s, args: [%s]', '${globalVariable}', a:module_key, a:method_name, join(a:args, ','))
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction

        function! ${declareVar}(module_key, var_name, expression)
          try
            let ${globalVariable}[a:module_key][a:var_name] = eval(a:expression)
          catch
            let ex = v:exception
            let msg = printf('error when declare %s.%s.%s, expression: %s', '${globalVariable}', a:module_key, a:var_name, a:expression)
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction
      `);
    const queue = [...this.initQueue];
    while (queue.length) {
      const it = queue.shift();
      try {
        await it.fn(context);
      } catch (error) {
        helperLogger.error(error);
      }
      if (this.initAfterQueue.length) {
        queue.push(...this.initAfterQueue);
        this.initAfterQueue = [];
      }
    }
  }
  static registerInit(description2, fn) {
    if (!this.inited) {
      this.initQueue.push({ description: description2, fn });
    } else {
      this.initAfterQueue.push({ description: description2, fn });
    }
  }
  static create(moduleName, cb) {
    const id = getModuleId("VimModule.module");
    const moduleKey = `${id}_${moduleName}`;
    const vMod = new VimModule(moduleKey);
    let mod = void 0;
    function initedMod() {
      if (!mod) {
        mod = cb(vMod);
      }
      return mod;
    }
    VimModule.registerInit(`module ${moduleKey}`, async () => {
      await import_coc5.workspace.nvim.call("execute", `
          if !exists('${globalVariable}.${moduleKey}')
            let ${globalVariable}.${moduleKey} = {}
          endif
        `);
      initedMod();
    });
    return new Proxy({}, {
      get(_o, key) {
        return Reflect.get(initedMod(), key);
      },
      has(_o, key) {
        return key in initedMod();
      },
      ownKeys() {
        return Object.keys(initedMod());
      }
    });
  }
  registerInit(description2, fn) {
    if (typeof description2 === "string") {
      return VimModule.registerInit(description2, fn);
    } else {
      return this.registerInit("", description2);
    }
  }
  fn(fnName, getContent) {
    const { nvim } = import_coc5.workspace;
    const name2 = `${globalVariable}.${this.moduleKey}.${fnName}`;
    const content = getContent({ name: name2 });
    this.registerInit(`fn ${name2}`, async () => {
      helperLogger.debug(`declare fn ${name2}`);
      await nvim.call("execute", [filterLineCont(content)]);
    });
    return {
      name: name2,
      inlineCall: (argsExpression = "") => `${callFunc}('${this.moduleKey}', '${fnName}', [${argsExpression}])`,
      call: (...args) => {
        helperLogger.debug(`call ${name2}`);
        return nvim.call(callFunc, [
          this.moduleKey,
          fnName,
          args
        ]);
      },
      callNotify: (...args) => {
        helperLogger.debug(`callNotify ${name2}`);
        return nvim.call(callFunc, [this.moduleKey, fnName, args], true);
      },
      callNotifier: (...args) => {
        helperLogger.debug(`callNotifier ${name2}`);
        return Notifier.create(() => {
          nvim.call(callFunc, [this.moduleKey, fnName, args], true);
        });
      }
    };
  }
  var(varName, expression) {
    const { nvim } = import_coc5.workspace;
    const name2 = `${globalVariable}.${this.moduleKey}.${varName}`;
    this.registerInit(`var ${name2}`, async () => {
      helperLogger.debug(`declare var ${name2}`);
      await nvim.call(declareVar, [
        this.moduleKey,
        varName,
        filterLineCont(expression)
      ]);
    });
    return {
      name: name2,
      inline: name2,
      get: () => {
        return nvim.eval(name2);
      },
      set: async (expression2) => {
        await nvim.call(declareVar, [
          this.moduleKey,
          varName,
          filterLineCont(expression2)
        ]);
      },
      setNotify: (expression2) => {
        nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression2)], true);
      },
      setNotifier: (expression2) => {
        return Notifier.create(() => {
          nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression2)], true);
        });
      }
    };
  }
};
VimModule.inited = false;
VimModule.initQueue = [];
VimModule.initAfterQueue = [];

// node_modules/coc-helper/lib/esm/modules/util.js
var import_coc6 = require("coc.nvim");
var utilModule = VimModule.create("util", (m) => {
  const isNvim = import_coc6.workspace.isNvim;
  return {
    globalCursorPosition: m.fn("global_cursor_position", ({ name: name2 }) => `
        function! ${name2}()
          let nr = winnr()
          let [row, col] = win_screenpos(nr)
          return [row + winline() - 2, col + wincol() - 2]
        endfunction
      `),
    isFloat: m.fn("is_float", ({ name: name2 }) => isNvim ? `
          function! ${name2}(winnr) abort
            if !exists('*nvim_win_get_config')
              return v:false
            endif
            let winid = win_getid(a:winnr)
            return nvim_win_get_config(winid)['relative'] != ''
          endfunction
        ` : `
          function! ${name2}(winnr) abort
            return v:false
          endfunction
        `),
    closeWinByBufnr: m.fn("close_win_by_bufnr", ({ name: name2 }) => `
        if exists('*nvim_win_close')
          function! ${name2}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winid = bufwinid(bufnr)
                if winid >= 0
                  call nvim_win_close(winid, v:true)
                endif
              catch
              endtry
            endfor
          endfunction
        else
          function! ${name2}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winnr = bufwinnr(bufnr)
                if winnr >= 0
                  execute winnr . 'wincmd c'
                endif
              catch
              endtry
            endfor
          endfunction
        endif
      `),
    runCocCmd: m.fn("run_coc_cmd", ({ name: name2 }) => `
      function! ${name2}(name, ...) abort
        return call('CocAction', extend(['runCommand', a:name], a:000))
      endfunction
    `),
    runCocCmdAsync: m.fn("run_coc_cmd_async", ({ name: name2 }) => `
      function! ${name2}(name, ...) abort
        return call('CocActionAsync', extend(['runCommand', a:name], a:000))
      endfunction
    `)
  };
});

// node_modules/coc-helper/lib/esm/events.js
var mid2 = getModuleId("events");
var uname = `m${mid2}_v${versionName}`;
var HelperEventEmitter = class {
  constructor(helperLogger2, concurrent = false) {
    this.helperLogger = helperLogger2;
    this.concurrent = concurrent;
    this.listenersMap = /* @__PURE__ */ new Map();
  }
  listeners(event) {
    if (!this.listenersMap.has(event)) {
      const listeners = [];
      this.listenersMap.set(event, listeners);
      return listeners;
    }
    return this.listenersMap.get(event);
  }
  once(event, listener, disposables) {
    this.listeners(event).push(async (...args) => {
      const result = await listener(...args);
      disposable.dispose();
      return result;
    });
    const disposable = import_coc7.Disposable.create(() => this.off(event, listener));
    if (disposables) {
      disposables.push(disposable);
    }
    return disposable;
  }
  on(event, listener, disposables) {
    this.listeners(event).push(listener);
    const disposable = import_coc7.Disposable.create(() => this.off(event, listener));
    if (disposables) {
      disposables.push(disposable);
    }
    return disposable;
  }
  off(event, listener) {
    if (typeof listener.cancel === "function") {
      listener.cancel();
    }
    const listeners = this.listeners(event);
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }
  async fire(event, ...args) {
    if (this.concurrent) {
      await Promise.all(this.listeners(event).map(async (listener) => {
        try {
          await listener(...args);
        } catch (e) {
          this.helperLogger.error(e);
        }
      }));
    } else {
      for (const listener of this.listeners(event)) {
        try {
          await listener(...args);
        } catch (e) {
          this.helperLogger.error(e);
        }
      }
    }
  }
};
var HelperVimEvents = class {
  constructor(vimEvents, helperLogger2, options = {}) {
    var _a;
    this.vimEvents = vimEvents;
    this.helperLogger = helperLogger2;
    this.options = options;
    this.id = getModuleId("events.id");
    this.augroupName = `CocHelperInternal_${uname}_${options.name ? `${options.name}_` : ""}${this.id}`;
    this.commandName = `coc-helper.internal.didVimEvent_${uname}_${options.name ? `${options.name}_` : ""}${this.id}`;
    this.events = new HelperEventEmitter(this.helperLogger, (_a = options.concurrent) !== null && _a !== void 0 ? _a : false);
  }
  async register(context) {
    await eventsModule.activate.call(this.augroupName, this.commandName, Object.entries(this.vimEvents).map(([key, e]) => Object.assign({ event: key }, e)));
    context.subscriptions.push(import_coc7.Disposable.create(async () => {
      await eventsModule.deactivate.call(this.augroupName);
    }));
    context.subscriptions.push(import_coc7.commands.registerCommand(this.commandName, helperLogger.asyncCatch((event, ...args) => this.events.fire(event, ...args)), void 0, true));
  }
};
var helperVimEvents = new HelperVimEvents({
  BufDelete: {
    eventExpr: "BufDelete *",
    argExprs: ["+expand('<abuf>')"]
  },
  BufWipeout: {
    eventExpr: "BufWipeout *",
    argExprs: ["+expand('<abuf>')"]
  }
}, helperLogger, {
  name: "coc_helper"
});
var helperEvents = helperVimEvents.events;
var eventsModule = VimModule.create("events", (m) => {
  const activate2 = m.fn("activate", ({ name: name2 }) => `
      function! ${name2}(augroup_name, autocmd_events) abort
        execute 'augroup ' . a:augroup_name
          autocmd!
          for autocmd_event in a:autocmd_events
            execute autocmd_event
          endfor
        augroup END
      endfunction
    `);
  function getActivateEvents(commandName, activateEvents) {
    return activateEvents.map((e) => {
      var _a;
      const args = `${[
        `'${commandName}'`,
        `'${e.event}'`,
        ...(_a = e.argExprs) !== null && _a !== void 0 ? _a : []
      ].join(", ")}`;
      return `autocmd ${e.eventExpr} call ${e.async === false ? utilModule.runCocCmd.inlineCall(args) : utilModule.runCocCmdAsync.inlineCall(args)}`;
    });
  }
  return {
    activate: {
      call: (augroupName, commandName, activateEvents) => activate2.call(augroupName, getActivateEvents(commandName, activateEvents)),
      callNotify: (augroupName, commandName, activateEvents) => activate2.callNotify(augroupName, getActivateEvents(commandName, activateEvents)),
      callNotifier: (augroupName, commandName, activateEvents) => activate2.callNotifier(augroupName, getActivateEvents(commandName, activateEvents))
    },
    deactivate: m.fn("deactivate", ({ name: name2 }) => `
        function! ${name2}(augroup_name) abort
          execute 'augroup ' . a:augroup_name
            autocmd!
          augroup END
        endfunction
      `),
    doAutocmd: m.fn("do_autocmd", ({ name: name2 }) => `
        function! ${name2}(name) abort
          if exists('#User#'.a:name)
            exe 'doautocmd <nomodeline> User '.a:name
          endif
        endfunction
      `)
  };
});

// node_modules/coc-helper/lib/esm/FloatingWindow.js
var import_coc11 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/modules/floating.js
var import_coc9 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/modules/buf.js
var import_coc8 = require("coc.nvim");
var bufModule = VimModule.create("buf", (m) => {
  const isNvim = import_coc8.workspace.isNvim;
  const createByName = m.fn("create_by_name", ({ name: name2 }) => `
      function! ${name2}(name) abort
        return bufadd(a:name)
      endfunction
    `);
  return {
    createByName,
    create: m.fn("create", ({ name: name2 }) => isNvim ? `
          function! ${name2}(...) abort
            let name = get(a:000, 0, '')
            if name is ''
              return nvim_create_buf(v:false, v:true)
            else
              return ${createByName.inlineCall("name")}
            endif
          endfunction
        ` : `
          function! ${name2}(...) abort
            let name = get(a:000, 0, '')
            return ${createByName.inlineCall("name")}
          endfunction
        `)
  };
});

// node_modules/coc-helper/lib/esm/modules/floating.js
var floatingModule = VimModule.create("float", (m) => {
  const isNvim = import_coc9.workspace.isNvim;
  const initExecute = m.fn("init_execute", ({ name: name2 }) => `
      function! ${name2}(ctx, inited_execute) abort
        execute a:inited_execute
      endfunction
    `);
  const openWin = m.fn("open_win", ({ name: name2 }) => isNvim ? `
        function! ${name2}(bufnr, focus, win_config, win_hl, inited_execute) abort
          noau let winid = nvim_open_win(a:bufnr, a:focus, a:win_config)
          if !empty(a:win_hl)
            call nvim_win_set_option(winid, 'winhl', a:win_hl)
          endif
          if !empty(a:inited_execute)
            call ${initExecute.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}
          endif
          return winid
        endfunction
      ` : `
        function! ${name2}(bufnr, focus, win_config, win_hl, inited_execute) abort
          let winid = popup_create(a:bufnr, a:win_config)
          call ${initExecute.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}

          return winid
        endfunction
      `);
  return {
    create: m.fn("create", ({ name: name2 }) => isNvim ? `
            function! ${name2}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${bufModule.create.inlineCall("a:name")}
              call ${initExecute.inlineCall("{'bufnr': bufnr}, a:inited_execute")}

              let border_bufnr = v:null
              if a:has_border_buf
                let border_bufnr = nvim_create_buf(v:false, v:true)
                call ${initExecute.inlineCall("{'bufnr': border_bufnr}, a:border_inited_execute")}
              endif
              return [bufnr, border_bufnr]
            endfunction
          ` : `
            function! ${name2}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${bufModule.create.inlineCall("a:name")}
              call ${initExecute.inlineCall("{'bufnr': bufnr}, a:inited_execute")}
              return [bufnr, v:null]
            endfunction
          `),
    open: m.fn("open", ({ name: name2 }) => `
        function! ${name2}(bufnr, win_config, inited_execute, border_bufnr, border_win_config, border_inited_execute, focus, win_hl) abort
          let winid = ${openWin.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, a:inited_execute")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${openWin.inlineCall("a:border_bufnr, v:false, a:border_win_config, a:win_hl, a:border_inited_execute")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),
    resume: m.fn("resume", ({ name: name2 }) => `
        function! ${name2}(bufnr, win_config, border_bufnr, border_win_config, focus, win_hl) abort
          let winid = ${openWin.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, ''")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${openWin.inlineCall("border_bufnr, v:false, a:border_win_config, a:win_hl, ''")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),
    update: m.fn("update", ({ name: name2 }) => isNvim ? `
          function! ${name2}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call nvim_win_set_config(winid, a:win_config)
            if !empty(a:win_hl)
              call nvim_win_set_option(winid, 'winhl', a:win_hl)
            endif
            if has('nvim')
              redraw!
            endif

            if a:border_bufnr
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              if border_winid
                call nvim_win_set_config(border_winid, a:border_win_config)
                if !empty(a:win_hl)
                  call nvim_win_set_option(border_winid, 'winhl', a:win_hl)
                endif
                if has('nvim')
                  redraw!
                endif
              endif
            endif
          endfunction
        ` : `
          function! ${name2}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call popup_setoptions(winid, a:win_config)
          endfunction
        `),
    winid: m.fn("winid", ({ name: name2 }) => `
        function! ${name2}(bufnr) abort
          let id = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
          let nr = win_id2win(id)
          return nr is 0 ? v:null : id
        endfunction
      `),
    borderWinid: m.fn("border_winid", ({ name: name2 }) => `
        function! ${name2}(bufnr) abort
          return getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
        endfunction
      `),
    close: m.fn("close", ({ name: name2 }) => isNvim ? `
            function! ${name2}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              try
                if winid
                  call nvim_win_close(winid, v:true)
                endif
                if border_winid
                  call nvim_win_close(border_winid, v:true)
                endif
              catch
              endtry
            endfunction
          ` : `
            function! ${name2}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              try
                if winid
                  call popup_close(winid)
                endif
              catch
              endtry
            endfunction
          `)
  };
});

// node_modules/coc-helper/lib/esm/FloatingUtil.js
var import_coc10 = require("coc.nvim");
var defaultBorderChars = ["\u2500", "\u2502", "\u2500", "\u2502", "\u250C", "\u2510", "\u2518", "\u2514"];
var defaultWinHl = "CocHelperNormalFloat";
var defaultWinHlNC = "CocHelperNormalFloatNC";
var defaultBorderWinHl = "CocHelperNormalFloatBorder";
var FloatingUtil = class {
  constructor(srcId) {
    this.srcId = srcId;
  }
  async createContext(options) {
    var _a, _b;
    return (_a = options.context) !== null && _a !== void 0 ? _a : {
      lines: import_coc10.workspace.env.lines,
      columns: import_coc10.workspace.env.columns - import_coc10.workspace.env.cmdheight - 1,
      globalCursorPosition: await utilModule.globalCursorPosition.call(),
      title: options.title ? {
        text: options.title,
        width: await displayWidth(options.title)
      } : { text: "", width: 0 },
      borderEnabled: !!options.border,
      border: this.extendEdges((_b = options.border) === null || _b === void 0 ? void 0 : _b.map((b) => typeof b === "boolean" ? 1 : b)),
      paddingEnabled: !!options.padding,
      padding: this.extendEdges(options.padding)
    };
  }
  getCenterPos(ctx, box) {
    const [, , width, height] = box;
    const top = Math.floor((ctx.lines - height) / 2);
    const left = Math.floor((ctx.columns - width) / 2);
    return [top, left];
  }
  getPosForAround(ctx, size, cursorPosition, preferAbove = false) {
    const columns = ctx.columns;
    const lines = ctx.lines - 1;
    const [width, height] = size;
    let [top, left] = cursorPosition;
    if (preferAbove) {
      if (top - height < 0) {
        top += 1;
      } else {
        top -= height;
      }
    } else {
      if (top + height >= lines) {
        top -= height;
      } else {
        top += 1;
      }
    }
    if (left + width >= columns) {
      left -= width - 1;
    }
    return [top, left];
  }
  extendEdges(edges) {
    var _a, _b, _c, _d;
    if (!edges) {
      return [0, 0, 0, 0];
    }
    const top = (_a = edges[0]) !== null && _a !== void 0 ? _a : 1;
    const right = (_b = edges[1]) !== null && _b !== void 0 ? _b : top;
    const bottom = (_c = edges[2]) !== null && _c !== void 0 ? _c : top;
    const left = (_d = edges[3]) !== null && _d !== void 0 ? _d : right;
    return [top, right, bottom, left];
  }
  changeBoxByEdgesList(box, edgesList) {
    let retBox = [...box];
    for (const edges of edgesList) {
      retBox = this.changeBoxByEdges(retBox, edges);
    }
    return retBox;
  }
  changeBoxByEdges(box, edges) {
    if (!edges) {
      return box;
    }
    const [wTop, wRight, wBottom, wLeft] = edges;
    let [top, left, width, height] = box;
    top -= wTop;
    left -= wLeft;
    width += wLeft + wRight;
    height += wTop + wBottom;
    return [top, left, width, height];
  }
  getBoxSizes(ctx, options, updateCursorPosition) {
    var _a, _b;
    const [top, left] = [(_a = options.top) !== null && _a !== void 0 ? _a : 0, (_b = options.left) !== null && _b !== void 0 ? _b : 0];
    const width = Math.max(options.width, ctx.title.width);
    const contentBox = [0, 0, width, options.height];
    const paddingBox = this.changeBoxByEdges(contentBox, ctx.padding);
    const borderBox = this.changeBoxByEdges(paddingBox, ctx.border);
    let fullPos;
    if (options.relative === "center") {
      fullPos = this.getCenterPos(ctx, borderBox);
    } else {
      const cursorPosition = !updateCursorPosition && this.storeCursorPosition ? this.storeCursorPosition : ctx.globalCursorPosition;
      if (options.relative === "cursor") {
        fullPos = cursorPosition;
      } else if (options.relative === "cursor-around") {
        fullPos = this.getPosForAround(ctx, [borderBox[2], borderBox[3]], cursorPosition);
      } else {
        fullPos = [top, left];
      }
      this.storeCursorPosition = cursorPosition;
    }
    [borderBox[0], borderBox[1]] = [fullPos[0], fullPos[1]];
    [paddingBox[0], paddingBox[1]] = [
      borderBox[0] + ctx.border[0],
      borderBox[1] + ctx.border[3]
    ];
    [contentBox[0], contentBox[1]] = [
      paddingBox[0] + ctx.padding[0],
      paddingBox[1] + ctx.padding[3]
    ];
    return {
      contentBox,
      paddingBox,
      borderBox
    };
  }
  vimWinConfig(ctx, options, updateCursorPosition) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const [top, left, width, height] = [
      (_a = options.top) !== null && _a !== void 0 ? _a : 0,
      (_b = options.left) !== null && _b !== void 0 ? _b : 0,
      options.width,
      options.height
    ];
    const config = {
      line: 0,
      col: 0,
      zindex: ((_c = options.borderOnly) !== null && _c !== void 0 ? _c : false) ? 1 : 100,
      minwidth: width,
      minheight: height,
      maxwidth: width,
      maxheight: height
    };
    if (options.relative === "center") {
      config.pos = "center";
    } else {
      const cursorPosition = !updateCursorPosition && this.storeCursorPosition ? this.storeCursorPosition : ctx.globalCursorPosition;
      if (options.relative === "cursor") {
        [config.line, config.col] = cursorPosition;
      } else if (options.relative === "cursor-around") {
        const box = this.changeBoxByEdgesList([top, left, width, height], [ctx.padding, ctx.border]);
        [config.line, config.col] = this.getPosForAround(ctx, [box[2], box[3]], cursorPosition);
      } else {
        [config.line, config.col] = [top, left];
      }
      this.storeCursorPosition = cursorPosition;
      config.line += 1;
      config.col += 1;
    }
    const topOffset = (_d = options.topOffset) !== null && _d !== void 0 ? _d : 0;
    const leftOffset = (_e = options.leftOffset) !== null && _e !== void 0 ? _e : 0;
    config.line += topOffset;
    config.col += leftOffset;
    if (options.maxWidth) {
      config.maxwidth = options.maxWidth;
    }
    if (options.maxHeight) {
      config.maxheight = options.maxHeight;
    }
    config.highlight = (_f = options.winHl) !== null && _f !== void 0 ? _f : defaultWinHl;
    if (options.padding) {
      config.padding = options.padding;
    }
    if (ctx.borderEnabled) {
      config.border = ctx.border;
      if (config.border[0]) {
        if (ctx.title.width) {
          config.title = ctx.title.text;
        }
        config.close = "button";
      }
      config.borderchars = (_g = options.borderChars) !== null && _g !== void 0 ? _g : defaultBorderChars;
      config.borderhighlight = [(_h = options.borderWinHl) !== null && _h !== void 0 ? _h : defaultBorderWinHl];
    }
    return config;
  }
  nvimWinConfig(ctx, options, updateCursorPosition) {
    var _a, _b, _c;
    const { contentBox, borderBox } = this.getBoxSizes(ctx, options, updateCursorPosition);
    const topOffset = (_a = options.topOffset) !== null && _a !== void 0 ? _a : 0;
    const leftOffset = (_b = options.leftOffset) !== null && _b !== void 0 ? _b : 0;
    const winConfig = {
      relative: "editor",
      row: contentBox[0] + topOffset,
      col: contentBox[1] + leftOffset,
      width: contentBox[2],
      height: contentBox[3],
      focusable: (_c = options.focusable) !== null && _c !== void 0 ? _c : true
    };
    let winConfigBorder;
    if (borderBox) {
      winConfigBorder = {
        relative: "editor",
        row: borderBox[0] + topOffset,
        col: borderBox[1] + leftOffset,
        width: borderBox[2],
        height: borderBox[3],
        focusable: false
      };
    }
    return [winConfig, winConfigBorder];
  }
  winConfig(ctx, options, updateCursorPosition = true) {
    return import_coc10.workspace.isVim ? [this.vimWinConfig(ctx, options, updateCursorPosition), void 0] : this.nvimWinConfig(ctx, options, updateCursorPosition);
  }
  getRenderBorderData(ctx, options, winOptions) {
    var _a, _b, _c, _d, _e, _f;
    const title = (_b = (_a = ctx.title) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    const titleWidth = (_d = (_c = ctx.title) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 0;
    if (!ctx.borderEnabled) {
      return;
    }
    const [bTop, bRight, bBottom, bLeft] = ctx.border;
    let [cTop, cRight, cBottom, cLeft, cTopleft, cTopright, cBotright, cBotleft] = (_e = options.borderChars) !== null && _e !== void 0 ? _e : defaultBorderChars;
    if (!bTop) {
      cTop = "";
    }
    if (!bRight) {
      cRight = "";
    }
    if (!bBottom) {
      cBottom = "";
    }
    if (!bLeft) {
      cLeft = "";
    }
    if (!bTop || !bLeft) {
      cTopleft = "";
    }
    if (!bTop || !bRight) {
      cTopright = "";
    }
    if (!bBottom || !bLeft) {
      cBotleft = "";
    }
    if (!bBottom || !bRight) {
      cBotright = "";
    }
    const width = winOptions[0];
    const height = winOptions[1];
    const spaceWidth = width - bLeft - bRight;
    const spaceHeight = height - bTop - bBottom;
    const lines = [];
    if (bTop) {
      lines.push(cTopleft + title + cTop.repeat(spaceWidth - titleWidth) + cTopright);
    }
    lines.push(...Array.from({ length: spaceHeight }, () => cLeft + " ".repeat(spaceWidth) + cRight));
    if (bBottom) {
      lines.push(cBotleft + cBottom.repeat(spaceWidth) + cBotright);
    }
    const highlights = [];
    const borderWinHl = (_f = options.borderWinHl) !== null && _f !== void 0 ? _f : defaultBorderWinHl;
    if (borderWinHl) {
      highlights.push({
        srcId: this.srcId,
        hlGroup: borderWinHl,
        line: 0,
        colStart: 0,
        colEnd: width
      });
      for (let l = 0, len = spaceHeight; l < len; l++) {
        if (bLeft) {
          highlights.push({
            srcId: this.srcId,
            hlGroup: borderWinHl,
            line: l + 1,
            colStart: 0,
            colEnd: bLeft
          });
        }
        if (bRight) {
          highlights.push({
            srcId: this.srcId,
            hlGroup: borderWinHl,
            line: l + 1,
            colStart: bLeft + spaceWidth,
            colEnd: width
          });
        }
      }
      if (bBottom) {
        highlights.push({
          srcId: this.srcId,
          hlGroup: borderWinHl,
          line: height - 1,
          colStart: 0,
          colEnd: width
        });
      }
    }
    return {
      lines,
      highlights
    };
  }
  renderBorderNotifier(buf, ctx, options, winOptions) {
    const renderData = this.getRenderBorderData(ctx, options, "width" in winOptions ? [winOptions.width, winOptions.height] : [winOptions.minwidth, winOptions.minheight]);
    if (!renderData) {
      return Notifier.noop();
    }
    const { lines, highlights } = renderData;
    return Notifier.create(() => {
      buf.setOption("modifiable", true, true);
      buf.setOption("readonly", false, true);
      void buf.setLines(lines, { start: 0, end: -1 }, true);
      buf.setOption("modifiable", false, true);
      buf.setOption("readonly", true, true);
      this.addHighlightsNotify(buf, highlights);
    });
  }
  nvimWinHl(options) {
    var _a, _b;
    if (import_coc10.workspace.isVim) {
      return "";
    }
    const arr = [];
    arr.push("Normal:" + ((_a = options.winHl) !== null && _a !== void 0 ? _a : defaultWinHl));
    arr.push("NormalNC:" + ((_b = options.winHlNC) !== null && _b !== void 0 ? _b : defaultWinHlNC));
    return arr.join(",");
  }
  addHighlightsNotify(buf, highlights) {
    for (const hl of highlights) {
      if (!hl.srcId || !hl.hlGroup || hl.line === void 0 || hl.colStart === void 0 || hl.colEnd === void 0) {
        continue;
      }
      buf.highlightRanges(this.srcId, hl.hlGroup, [
        import_coc10.Range.create(hl.line, hl.colStart, hl.line, hl.colEnd)
      ]);
    }
  }
};

// node_modules/coc-helper/lib/esm/FloatingWindow.js
var FloatingWindow = class {
  constructor(bufnr, borderBufnr, createOptions, mode, util2) {
    this.bufnr = bufnr;
    this.borderBufnr = borderBufnr;
    this.createOptions = createOptions;
    this.mode = mode;
    this.util = util2;
    this.nvim = import_coc11.workspace.nvim;
    this.disposables = [];
    this.nvim = import_coc11.workspace.nvim;
    this.buffer = this.nvim.createBuffer(bufnr);
    if (borderBufnr) {
      this.borderBuffer = import_coc11.workspace.nvim.createBuffer(borderBufnr);
      this.disposables.push(import_coc11.events.on("BufWinLeave", helperLogger.asyncCatch(async (curBufnr) => {
        if (this.borderBufnr && curBufnr === this.bufnr) {
          await utilModule.closeWinByBufnr.call([this.borderBufnr]);
        }
      })));
    }
  }
  static getInitedExecute(mode, options) {
    var _a, _b, _c, _d;
    let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, FloatingWindow.initedContextVars.create)) !== null && _b !== void 0 ? _b : "";
    initedExecute = FloatingWindow.modePresets[mode].createInitedExecute(FloatingWindow.initedContextVars.create) + "\n" + initedExecute;
    const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, FloatingWindow.initedContextVars.create)) !== null && _d !== void 0 ? _d : FloatingWindow.modePresets.show.createInitedExecute(FloatingWindow.initedContextVars.create);
    return [initedExecute, borderInitedExecute];
  }
  static async create(options = {}) {
    var _a, _b, _c;
    const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : "default";
    const [initedExecute, borderInitedExecute] = this.getInitedExecute(mode, options);
    const [bufnr, borderBufnr] = await floatingModule.create.call((_b = options.name) !== null && _b !== void 0 ? _b : "", initedExecute, (_c = options.hasBorderBuf) !== null && _c !== void 0 ? _c : true, borderInitedExecute);
    const floatingUtil = new FloatingUtil(this.srcId);
    return new FloatingWindow(bufnr, borderBufnr !== null && borderBufnr !== void 0 ? borderBufnr : void 0, options, mode, floatingUtil);
  }
  getInitedExecute(options) {
    var _a, _b, _c, _d;
    let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, FloatingWindow.initedContextVars.open)) !== null && _b !== void 0 ? _b : "";
    initedExecute = FloatingWindow.modePresets[this.mode].openInitedExecute(FloatingWindow.initedContextVars.open) + "\n" + initedExecute;
    const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, FloatingWindow.initedContextVars.open)) !== null && _d !== void 0 ? _d : FloatingWindow.modePresets.show.openInitedExecute(FloatingWindow.initedContextVars.open);
    return [initedExecute, borderInitedExecute];
  }
  getFocus(options) {
    var _a, _b;
    return (_b = (_a = options.focus) !== null && _a !== void 0 ? _a : this.mode ? FloatingWindow.modePresets[this.mode].focus : void 0) !== null && _b !== void 0 ? _b : false;
  }
  getModifiable(options) {
    var _a, _b;
    return (_b = (_a = options.modifiable) !== null && _a !== void 0 ? _a : this.mode ? FloatingWindow.modePresets[this.mode].modifiable : void 0) !== null && _b !== void 0 ? _b : false;
  }
  setLinesNotifier(options) {
    return Notifier.create(() => {
      if (!options.lines && !options.modifiable) {
        return;
      }
      const modifiable = this.getModifiable(options);
      this.buffer.setOption("modifiable", true, true);
      this.buffer.setOption("readonly", false, true);
      if (options.lines) {
        void this.buffer.setLines(options.lines, { start: 0, end: -1 }, true);
      }
      if (!modifiable) {
        this.buffer.setOption("modifiable", false, true);
        this.buffer.setOption("readonly", true, true);
      }
      if (options.highlights) {
        for (const hl of options.highlights) {
          if (hl.srcId === void 0 || hl.srcId === -1 || hl.srcId === 0) {
            hl.srcId = FloatingWindow.srcId;
          }
          this.util.addHighlightsNotify(this.buffer, [hl]);
        }
      }
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    });
  }
  async setLines(options) {
    await this.setLinesNotifier(options).run();
  }
  async opened() {
    const win = await this.win();
    return !!win;
  }
  async openNotifier(options) {
    var _a;
    if (options.width <= 0 || options.height <= 0) {
      return Notifier.noop();
    }
    const notifiers = [];
    notifiers.push(this.closeNotifier());
    const ctx = await this.util.createContext(options);
    const [initedExecute, borderInitedExecute] = this.getInitedExecute(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
    if (options.borderOnly && borderWinConfig) {
      notifiers.push(floatingModule.open.callNotifier(this.bufnr, borderWinConfig, borderInitedExecute, null, null, "", false, this.util.nvimWinHl(options)));
      notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
    } else {
      notifiers.push(floatingModule.open.callNotifier(this.bufnr, winConfig, initedExecute, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, borderInitedExecute, this.getFocus(options), this.util.nvimWinHl(options)));
    }
    if (import_coc11.workspace.isNvim && this.borderBuffer && borderWinConfig) {
      notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
    }
    notifiers.push(this.setLinesNotifier(options), Notifier.create(() => {
      if (options.filetype) {
        this.buffer.setOption("filetype", options.filetype, true);
      }
    }));
    return Notifier.combine(notifiers);
  }
  async open(options) {
    await (await this.openNotifier(options)).run();
  }
  async resumeNotifier(options) {
    const ctx = await this.util.createContext(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
    return Notifier.create(() => {
      var _a;
      floatingModule.resume.callNotify(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.getFocus(options), this.util.nvimWinHl(options));
      if (this.borderBuffer && borderWinConfig) {
        this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig).notify();
      }
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    });
  }
  async resume(options) {
    await (await this.resumeNotifier(options)).run();
  }
  async resizeNotifier(options) {
    var _a;
    const ctx = await this.util.createContext(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options, false);
    const notifiers = [];
    if (options.borderOnly && borderWinConfig) {
      notifiers.push(floatingModule.update.callNotifier(this.bufnr, borderWinConfig, null, null, this.util.nvimWinHl(options)));
      notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
    } else {
      notifiers.push(floatingModule.update.callNotifier(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.util.nvimWinHl(options)));
    }
    if (import_coc11.workspace.isNvim && this.borderBuffer && borderWinConfig) {
      notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
    }
    notifiers.push(Notifier.create(() => {
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    }));
    return Notifier.combine(notifiers);
  }
  async resize(options) {
    await (await this.resizeNotifier(options)).run();
  }
  async win() {
    const winid = await floatingModule.winid.call(this.bufnr);
    return winid ? this.nvim.createWindow(winid) : void 0;
  }
  async borderWin() {
    const borderWinid = await floatingModule.winid.call(this.bufnr);
    return borderWinid ? this.nvim.createWindow(borderWinid) : void 0;
  }
  closeNotifier() {
    return floatingModule.close.callNotifier(this.bufnr);
  }
  async close() {
    await this.closeNotifier().run();
  }
  dispose() {
    (0, import_coc11.disposeAll)(this.disposables);
    this.disposables.forEach((s) => s.dispose());
  }
};
FloatingWindow.modePresets = {
  default: {
    modifiable: false,
    focus: false,
    createInitedExecute: () => "",
    openInitedExecute: () => ""
  },
  base: {
    createInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&buftype', 'nofile')
        call setbufvar(${ctx.bufnr}, '&bufhidden', 'hide')
        call setbufvar(${ctx.bufnr}, '&buflisted', 0)

        call setbufvar(${ctx.bufnr}, '&wrap', 1)

        call setbufvar(${ctx.bufnr}, '&swapfile', 0)

        call setbufvar(${ctx.bufnr}, '&modeline', 0)
      `,
    openInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&list', 0)

        call setbufvar(${ctx.bufnr}, '&listchars', '')
        if has('nvim')
          call setbufvar(${ctx.bufnr}, '&fillchars', 'eob: ')
        endif

        call setbufvar(${ctx.bufnr}, '&signcolumn', 'no')
        call setbufvar(${ctx.bufnr}, '&number', 0)
        call setbufvar(${ctx.bufnr}, '&relativenumber', 0)
        call setbufvar(${ctx.bufnr}, '&foldenable', 0)
        call setbufvar(${ctx.bufnr}, '&foldcolumn', 0)

        call setbufvar(${ctx.bufnr}, '&spell', 0)

        call setbufvar(${ctx.bufnr}, '&cursorcolumn', 0)
        call setbufvar(${ctx.bufnr}, '&cursorline', 0)
        call setbufvar(${ctx.bufnr}, '&colorcolumn', '')
      `
  },
  show: {
    modifiable: false,
    createInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.createInitedExecute(ctx)}
        " call setbufvar(${ctx.bufnr}, '&undofile', 0)
        " call setbufvar(${ctx.bufnr}, '&undolevels', -1)

        call setbufvar(${ctx.bufnr}, '&modifiable', 0)
        call setbufvar(${ctx.bufnr}, '&modified', 0)
        call setbufvar(${ctx.bufnr}, '&readonly', 1)
      `,
    openInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.openInitedExecute(ctx)}
      `
  }
};
FloatingWindow.initedContextVars = {
  create: { bufnr: "a:ctx.bufnr" },
  open: { bufnr: "a:ctx.bufnr", winid: "a:ctx.winid" }
};
FloatingWindow.srcId = import_coc11.workspace.createNameSpace("coc-helper-floatwin");

// node_modules/coc-helper/lib/esm/MultiFloatingWindow.js
var import_coc12 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/WinLayoutFinder.js
var import_coc13 = require("coc.nvim");

// src/util.ts
var import_coc15 = require("coc.nvim");
var logger = new HelperLogger("markdown-preview-enhanced");
var webviewExt;
var getWebviewAPI = () => {
  if (!webviewExt) {
    webviewExt = import_coc15.extensions.all.find((ext) => ext.id === "coc-webview");
  }
  if (!webviewExt) {
    void import_coc15.window.showErrorMessage("Please install the coc-webview extension");
    throw new Error("Please install the coc-webview extension");
  }
  return webviewExt.exports;
};

// src/image-helper.ts
async function pasteImageFile(sourceUri, imageFilePath) {
  const finalSourceUri = typeof sourceUri === "string" ? import_coc16.Uri.parse(sourceUri) : sourceUri;
  const imageFolderPath = import_coc16.workspace.getConfiguration("markdown-preview-enhanced").get("imageFolderPath");
  let imageFileName = path.basename(imageFilePath);
  const projectDirectoryPath = import_coc16.workspace.root;
  let assetDirectoryPath;
  let description2;
  if (imageFolderPath[0] === "/") {
    assetDirectoryPath = path.resolve(projectDirectoryPath, `.${imageFolderPath}`);
  } else {
    assetDirectoryPath = path.resolve(path.dirname(finalSourceUri.fsPath), imageFolderPath);
  }
  const destPath = path.resolve(assetDirectoryPath, path.basename(imageFilePath));
  const doc = await import_coc16.workspace.document;
  const pos = await import_coc16.window.getCursorPosition();
  fs.mkdir(assetDirectoryPath, () => {
    fs.stat(destPath, (err) => {
      if (err == null) {
        const lastDotOffset = imageFileName.lastIndexOf(".");
        const uid = `_${Math.random().toString(36).substring(2, 10)}`;
        if (lastDotOffset > 0) {
          description2 = imageFileName.slice(0, lastDotOffset);
          imageFileName = imageFileName.slice(0, lastDotOffset) + uid + imageFileName.slice(lastDotOffset, imageFileName.length);
        } else {
          description2 = imageFileName;
          imageFileName = imageFileName + uid;
        }
        fs.createReadStream(imageFilePath).pipe(fs.createWriteStream(path.resolve(assetDirectoryPath, imageFileName)));
      } else if (err.code === "ENOENT") {
        fs.createReadStream(imageFilePath).pipe(fs.createWriteStream(destPath));
        if (imageFileName.lastIndexOf(".")) {
          description2 = imageFileName.slice(0, imageFileName.lastIndexOf("."));
        } else {
          description2 = imageFileName;
        }
      } else {
        import_coc16.window.showErrorMessage(err.toString()).catch(logger.error);
      }
      void import_coc16.window.showInformationMessage(`Image ${imageFileName} has been copied to folder ${assetDirectoryPath}`);
      let url = `${imageFolderPath}/${imageFileName}`;
      if (url.indexOf(" ") >= 0) {
        url = url.replace(/ /g, "%20");
      }
      doc.applyEdits([import_coc16.TextEdit.insert(pos, `![${description2}](${url})`)]).catch(logger.error);
    });
  });
}
function replaceHint(doc, line, hint, withStr) {
  const textLine = doc.getline(line);
  if (textLine.indexOf(hint) >= 0) {
    doc.applyEdits([
      import_coc16.TextEdit.replace(import_coc16.Range.create(import_coc16.Position.create(line, 0), import_coc16.Position.create(line, textLine.length)), textLine.replace(hint, withStr))
    ]).catch(logger.error);
    return true;
  }
  return false;
}
function setUploadedImageURL(imageFileName, url, doc, hint, curPos) {
  let description2;
  if (imageFileName.lastIndexOf(".")) {
    description2 = imageFileName.slice(0, imageFileName.lastIndexOf("."));
  } else {
    description2 = imageFileName;
  }
  const withStr = `![${description2}](${url})`;
  if (!replaceHint(doc, curPos.line, hint, withStr)) {
    let i = curPos.line - 20;
    while (i <= curPos.line + 20) {
      if (replaceHint(doc, i, hint, withStr)) {
        break;
      }
      i++;
    }
  }
}
async function uploadImageFile(sourceUri, imageFilePath, imageUploader) {
  if (typeof sourceUri === "string") {
    sourceUri = import_coc16.Uri.parse(sourceUri);
  }
  const imageFileName = path.basename(imageFilePath);
  const doc = await import_coc16.workspace.document;
  const uid = Math.random().toString(36).substring(2, 10);
  const hint = `![Uploading ${imageFileName}\u2026 (${uid})]()`;
  const curPos = await import_coc16.window.getCursorPosition();
  await doc.applyEdits([import_coc16.TextEdit.insert(curPos, hint)]);
  const config = import_coc16.workspace.getConfiguration("markdown-preview-enhanced");
  const AccessKey = config.get("AccessKey") || "";
  const SecretKey = config.get("SecretKey") || "";
  const Bucket = config.get("Bucket") || "";
  const Domain = config.get("Domain") || "";
  import_mume.utility.uploadImage(imageFilePath, {
    method: imageUploader,
    qiniu: { AccessKey, SecretKey, Bucket, Domain }
  }).then((url) => {
    setUploadedImageURL(imageFileName, url, doc, hint, curPos);
  }).catch(logger.error);
}

// src/preview-content-provider.ts
var mume = __toESM(require("@shd101wyy/mume"));
var import_mume2 = require("@shd101wyy/mume");
var import_utility = require("@shd101wyy/mume/out/src/utility");
var import_coc18 = require("coc.nvim");
var import_path = __toESM(require("path"));

// src/config.ts
var import_coc17 = require("coc.nvim");
var MarkdownPreviewEnhancedConfig = class {
  static getCurrentConfig() {
    return new MarkdownPreviewEnhancedConfig();
  }
  constructor() {
    const config = import_coc17.workspace.getConfiguration("markdown-preview-enhanced");
    this.configPath = (config.get("configPath") || "").trim();
    this.usePandocParser = config.get("usePandocParser");
    this.breakOnSingleNewLine = config.get("breakOnSingleNewLine");
    this.enableTypographer = config.get("enableTypographer");
    this.enableWikiLinkSyntax = config.get("enableWikiLinkSyntax");
    this.enableLinkify = config.get("enableLinkify");
    this.useGitHubStylePipedLink = config.get("useGitHubStylePipedLink");
    this.wikiLinkFileExtension = config.get("wikiLinkFileExtension");
    this.enableEmojiSyntax = config.get("enableEmojiSyntax");
    this.enableExtendedTableSyntax = config.get("enableExtendedTableSyntax");
    this.enableCriticMarkupSyntax = config.get("enableCriticMarkupSyntax");
    this.frontMatterRenderingOption = config.get("frontMatterRenderingOption");
    this.mermaidTheme = config.get("mermaidTheme");
    this.mathRenderingOption = config.get("mathRenderingOption");
    this.mathInlineDelimiters = config.get("mathInlineDelimiters");
    this.mathBlockDelimiters = config.get("mathBlockDelimiters");
    this.mathRenderingOnlineService = config.get("mathRenderingOnlineService");
    this.codeBlockTheme = config.get("codeBlockTheme");
    this.previewTheme = config.get("previewTheme");
    this.revealjsTheme = config.get("revealjsTheme");
    this.protocolsWhiteList = config.get("protocolsWhiteList");
    this.imageFolderPath = config.get("imageFolderPath");
    this.imageUploader = config.get("imageUploader");
    this.printBackground = config.get("printBackground");
    this.chromePath = config.get("chromePath");
    this.imageMagickPath = config.get("imageMagickPath");
    this.pandocPath = config.get("pandocPath");
    this.pandocMarkdownFlavor = config.get("pandocMarkdownFlavor");
    this.pandocArguments = config.get("pandocArguments");
    this.latexEngine = config.get("latexEngine");
    this.enableScriptExecution = config.get("enableScriptExecution");
    this.scrollSync = config.get("scrollSync");
    this.liveUpdate = config.get("liveUpdate");
    this.singlePreview = config.get("singlePreview");
    this.automaticallyShowPreviewOfMarkdownBeingEdited = config.get("automaticallyShowPreviewOfMarkdownBeingEdited");
    this.enableHTML5Embed = config.get("enableHTML5Embed");
    this.HTML5EmbedUseImageSyntax = config.get("HTML5EmbedUseImageSyntax");
    this.HTML5EmbedUseLinkSyntax = config.get("HTML5EmbedUseLinkSyntax");
    this.HTML5EmbedIsAllowedHttp = config.get("HTML5EmbedIsAllowedHttp");
    this.HTML5EmbedAudioAttributes = config.get("HTML5EmbedAudioAttributes");
    this.HTML5EmbedVideoAttributes = config.get("HTML5EmbedVideoAttributes");
    this.puppeteerWaitForTimeout = config.get("puppeteerWaitForTimeout");
    this.usePuppeteerCore = config.get("usePuppeteerCore");
    this.puppeteerArgs = config.get("puppeteerArgs");
    this.plantumlServer = config.get("plantumlServer");
  }
  isEqualTo(otherConfig) {
    const json1 = JSON.stringify(this);
    const json2 = JSON.stringify(otherConfig);
    return json1 === json2;
  }
};

// src/preview-content-provider.ts
var MarkdownPreviewEnhancedView = class {
  constructor(context) {
    this.context = context;
    this.waiting = false;
    this.engineMaps = {};
    this.previewMaps = {};
    this.preview2EditorMap = /* @__PURE__ */ new Map();
    this.singlePreviewPanel = null;
    this.singlePreviewPanelSourceUriTarget = null;
    this.jsAndCssFilesMaps = {};
    this.config = MarkdownPreviewEnhancedConfig.getCurrentConfig();
    mume.init(this.config.configPath).then(async () => {
      mume.onDidChangeConfigFile(this.refreshAllPreviews.bind(this));
      import_mume2.MarkdownEngine.onModifySource(this.modifySource.bind(this));
      (0, import_utility.useExternalAddFileProtocolFunction)((filePath, preview) => {
        if (preview) {
          return preview.webview.asWebviewUri(import_coc18.Uri.file(filePath)).toString(true).replace(/%3F/gi, "?").replace(/%23/g, "#");
        } else {
          if (!filePath.startsWith("file://")) {
            filePath = `file:///${filePath}`;
          }
          filePath = filePath.replace(/^file:\/+/, "file:///");
          return filePath;
        }
      });
    }).catch((error) => {
      void import_coc18.window.showErrorMessage(error.toString());
    });
  }
  refreshAllPreviews() {
    for (const key in this.engineMaps) {
      if (Object.prototype.hasOwnProperty.call(this.engineMaps, key)) {
        const engine = this.engineMaps[key];
        if (engine) {
          engine.clearCaches();
        }
      }
    }
    if (useSinglePreview()) {
      if (!this.singlePreviewPanelSourceUriTarget) {
        return;
      }
      this.refreshPreviewPanel(this.singlePreviewPanelSourceUriTarget);
    } else {
      for (const key in this.previewMaps) {
        if (Object.prototype.hasOwnProperty.call(this.previewMaps, key)) {
          this.refreshPreviewPanel(import_coc18.Uri.file(key));
        }
      }
    }
  }
  async modifySource(codeChunkData, result, filePath) {
    async function insertResult(i, doc2) {
      const lineCount = doc2.lineCount;
      let start = 0;
      for (let j = i + 1; j < i + 6 && j < lineCount; j++) {
        if (doc2.getline(j).startsWith("<!-- code_chunk_output -->")) {
          start = j;
          break;
        }
      }
      if (start) {
        let end = start + 1;
        while (end < lineCount) {
          if (doc2.getline(end).startsWith("<!-- /code_chunk_output -->")) {
            break;
          }
          end += 1;
        }
        let r = "";
        for (let i2 = start + 2; i2 < end - 1; i2++) {
          r += `${doc2.getline(i2)}
`;
        }
        if (r === `${result}
`) {
          return "";
        }
        await doc2.applyEdits([
          import_coc18.TextEdit.replace(import_coc18.Range.create(import_coc18.Position.create(start + 2, 0), import_coc18.Position.create(end - 1, 0)), `${result}
`)
        ]);
        return "";
      } else {
        await doc2.applyEdits([
          import_coc18.TextEdit.insert(import_coc18.Position.create(i + 1, 0), `
<!-- code_chunk_output -->

${result}

<!-- /code_chunk_output -->
`)
        ]);
        return "";
      }
    }
    const doc = await import_coc18.workspace.document;
    if (this.formatPathIfNecessary(doc.uri) === filePath) {
      let codeChunkOffset = 0;
      const targetCodeChunkOffset = codeChunkData.normalizedInfo.attributes["code_chunk_offset"];
      const lineCount = doc.lineCount;
      for (let i2 = 0; i2 < lineCount; i2++) {
        const line = doc.getline(i2);
        if (line.match(/^```(.+)"?cmd"?\s*[=\s}]/)) {
          if (codeChunkOffset === targetCodeChunkOffset) {
            i2 = i2 + 1;
            while (i2 < lineCount) {
              if (doc.getline(i2).match(/^```\s*/)) {
                break;
              }
              i2 += 1;
            }
            return insertResult(i2, doc);
          } else {
            codeChunkOffset++;
          }
        } else if (line.match(/@import\s+(.+)"?cmd"?\s*[=\s}]/)) {
          if (codeChunkOffset === targetCodeChunkOffset) {
            return insertResult(i2, doc);
          } else {
            codeChunkOffset++;
          }
        }
      }
    }
    return "";
  }
  getEngine(sourceUri) {
    return this.engineMaps[sourceUri.fsPath];
  }
  getPreview(sourceUri) {
    if (useSinglePreview()) {
      return this.singlePreviewPanel;
    } else {
      return this.previewMaps[sourceUri.fsPath];
    }
  }
  isPreviewOn(sourceUri) {
    if (useSinglePreview()) {
      return !!this.singlePreviewPanel;
    } else {
      return !!this.getPreview(sourceUri);
    }
  }
  destroyPreview(sourceUri) {
    if (useSinglePreview()) {
      this.singlePreviewPanel = null;
      this.singlePreviewPanelSourceUriTarget = null;
      this.preview2EditorMap = /* @__PURE__ */ new Map();
      this.previewMaps = {};
    } else {
      const previewPanel = this.getPreview(sourceUri);
      if (previewPanel) {
        this.preview2EditorMap.delete(previewPanel);
        delete this.previewMaps[sourceUri.fsPath];
      }
    }
  }
  destroyEngine(sourceUri) {
    if (useSinglePreview()) {
      return this.engineMaps = {};
    }
    const engine = this.getEngine(sourceUri);
    if (engine) {
      delete this.engineMaps[sourceUri.fsPath];
    }
  }
  formatPathIfNecessary(pathString) {
    if (process.platform === "win32") {
      pathString = pathString.replace(/^([a-zA-Z]):\\/, (_, $1) => `${$1.toUpperCase()}:\\`);
    }
    return pathString;
  }
  getProjectDirectoryPath(sourceUri, workspaceFolders = []) {
    const possibleWorkspaceFolders = workspaceFolders.filter((workspaceFolder) => {
      return import_path.default.dirname(sourceUri.path.toUpperCase()).indexOf(workspaceFolder.uri.toUpperCase()) >= 0;
    });
    let projectDirectoryPath;
    if (possibleWorkspaceFolders.length) {
      const workspaceFolder = possibleWorkspaceFolders.sort((x, y) => y.uri.length - x.uri.length)[0];
      projectDirectoryPath = workspaceFolder.uri;
    } else {
      projectDirectoryPath = "";
    }
    return this.formatPathIfNecessary(projectDirectoryPath);
  }
  getFilePath(sourceUri) {
    return this.formatPathIfNecessary(sourceUri.fsPath);
  }
  initMarkdownEngine(sourceUri) {
    let engine = this.getEngine(sourceUri);
    if (!engine) {
      engine = new import_mume2.MarkdownEngine({
        filePath: this.getFilePath(sourceUri),
        projectDirectoryPath: this.getProjectDirectoryPath(sourceUri, import_coc18.workspace.workspaceFolders),
        config: this.config
      });
      this.engineMaps[sourceUri.fsPath] = engine;
      this.jsAndCssFilesMaps[sourceUri.fsPath] = [];
    }
    return engine;
  }
  getWebviewOptions(localResourceRoots) {
    return {
      enableScripts: true,
      localResourceRoots
    };
  }
  async initPreview(sourceUri, doc, openURL) {
    const isUsingSinglePreview = useSinglePreview();
    let previewPanel;
    if (isUsingSinglePreview && this.singlePreviewPanel) {
      if (!this.singlePreviewPanelSourceUriTarget) {
        return;
      }
      const oldResourceRoot = this.getProjectDirectoryPath(this.singlePreviewPanelSourceUriTarget, import_coc18.workspace.workspaceFolders) || import_path.default.dirname(this.singlePreviewPanelSourceUriTarget.fsPath);
      const newResourceRoot = this.getProjectDirectoryPath(sourceUri, import_coc18.workspace.workspaceFolders) || import_path.default.dirname(sourceUri.fsPath);
      if (oldResourceRoot !== newResourceRoot) {
        this.singlePreviewPanel.dispose();
        return this.initPreview(sourceUri, doc, openURL);
      } else {
        previewPanel = this.singlePreviewPanel;
        this.singlePreviewPanelSourceUriTarget = sourceUri;
        if (openURL) {
          previewPanel.reveal({
            openURL
          });
        }
      }
    } else if (this.previewMaps[sourceUri.fsPath]) {
      previewPanel = this.previewMaps[sourceUri.fsPath];
      if (openURL) {
        previewPanel.reveal({
          openURL
        });
      }
    } else {
      const localResourceRoots = [
        import_coc18.Uri.file(this.context.extensionPath),
        import_coc18.Uri.file(mume.utility.extensionDirectoryPath),
        import_coc18.Uri.file(mume.getExtensionConfigPath()),
        import_coc18.Uri.file(this.getProjectDirectoryPath(sourceUri, import_coc18.workspace.workspaceFolders) || import_path.default.dirname(sourceUri.fsPath))
      ];
      previewPanel = await getWebviewAPI().createWebviewPanel("markdown-preview-enhanced", `Preview ${import_path.default.basename(sourceUri.fsPath)}`, {
        openURL,
        routeName: "markdown-preview-enhanced"
      }, this.getWebviewOptions(localResourceRoots));
      previewPanel.iconPath = import_coc18.Uri.file(import_path.default.join(this.context.extensionPath, "media", "preview.svg"));
      previewPanel.webview.onDidReceiveMessage((message) => {
        import_coc18.commands.executeCommand(`_mume.${message.command}`, ...message.args).catch(logger.error);
      }, null, this.context.subscriptions);
      previewPanel.onDidDispose(() => {
        this.destroyPreview(sourceUri);
        this.destroyEngine(sourceUri);
      }, null, this.context.subscriptions);
      if (isUsingSinglePreview) {
        this.singlePreviewPanel = previewPanel;
        this.singlePreviewPanelSourceUriTarget = sourceUri;
      }
    }
    this.previewMaps[sourceUri.fsPath] = previewPanel;
    this.preview2EditorMap.set(previewPanel, doc);
    previewPanel.title = `Preview ${import_path.default.basename(sourceUri.fsPath)}`;
    let initialLine;
    if (doc && doc.uri === sourceUri.fsPath) {
      const cursor = await (await import_coc18.workspace.nvim.window).cursor;
      initialLine = cursor[0] ? cursor[0] - 1 : 0;
    }
    const text = doc.getDocumentContent();
    let engine = this.getEngine(sourceUri);
    if (!engine) {
      engine = this.initMarkdownEngine(sourceUri);
    }
    engine.generateHTMLTemplateForPreview({
      inputString: text,
      config: {
        sourceUri: sourceUri.toString(),
        initialLine,
        vscode: true
      },
      contentSecurityPolicy: "",
      vscodePreviewPanel: previewPanel
    }).then((html) => {
      previewPanel.webview.html = html;
    }).catch(logger.error);
  }
  closeAllPreviews(singlePreview) {
    if (singlePreview) {
      if (this.singlePreviewPanel) {
        this.singlePreviewPanel.dispose();
      }
    } else {
      const previewPanels = [];
      for (const key in this.previewMaps) {
        if (Object.prototype.hasOwnProperty.call(this.previewMaps, key)) {
          const previewPanel = this.previewMaps[key];
          if (previewPanel) {
            previewPanels.push(previewPanel);
          }
        }
      }
      previewPanels.forEach((previewPanel) => previewPanel.dispose());
    }
    this.previewMaps = {};
    this.preview2EditorMap = /* @__PURE__ */ new Map();
    this.engineMaps = {};
    this.singlePreviewPanel = null;
    this.singlePreviewPanelSourceUriTarget = null;
  }
  previewPostMessage(sourceUri, message) {
    const preview = this.getPreview(sourceUri);
    if (preview) {
      void preview.webview.postMessage(message);
    }
  }
  previewHasTheSameSingleSourceUri(sourceUri) {
    if (!this.singlePreviewPanelSourceUriTarget) {
      return false;
    } else {
      return this.singlePreviewPanelSourceUriTarget.fsPath === sourceUri.fsPath;
    }
  }
  updateMarkdown(sourceUri, triggeredBySave) {
    const engine = this.getEngine(sourceUri);
    if (!engine) {
      return;
    }
    const previewPanel = this.getPreview(sourceUri);
    if (!previewPanel) {
      return;
    }
    if (engine.isPreviewInPresentationMode) {
      return this.refreshPreview(sourceUri);
    }
    const doc = import_coc18.workspace.getDocument(sourceUri.path);
    const text = doc.getDocumentContent();
    this.previewPostMessage(sourceUri, {
      command: "startParsingMarkdown"
    });
    const preview = this.getPreview(sourceUri);
    engine.parseMD(text, {
      isForPreview: true,
      useRelativeFilePath: false,
      hideFrontMatter: false,
      triggeredBySave,
      vscodePreviewPanel: preview
    }).then(({ html, tocHTML, JSAndCssFiles, yamlConfig }) => {
      if (JSON.stringify(JSAndCssFiles) !== JSON.stringify(this.jsAndCssFilesMaps[sourceUri.fsPath]) || yamlConfig["isPresentationMode"]) {
        this.jsAndCssFilesMaps[sourceUri.fsPath] = JSAndCssFiles;
        this.refreshPreview(sourceUri);
      } else {
        this.previewPostMessage(sourceUri, {
          command: "updateHTML",
          html,
          tocHTML,
          totalLineCount: doc.lineCount,
          sourceUri: sourceUri.toString(),
          id: yamlConfig.id || "",
          class: yamlConfig.class || ""
        });
      }
    }).catch(logger.error);
  }
  refreshPreviewPanel(sourceUri) {
    this.preview2EditorMap.forEach((doc, previewPanel) => {
      if (previewPanel && doc && isMarkdownFile(doc.textDocument) && doc.uri && doc.uri === sourceUri.fsPath) {
        void this.initPreview(sourceUri, doc, false);
      }
    });
  }
  refreshPreview(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.clearCaches();
      this.refreshPreviewPanel(sourceUri);
    }
  }
  openInBrowser(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.openInBrowser({}).catch((error) => {
        import_coc18.window.showErrorMessage(error.toString()).catch(logger.error);
      });
    }
  }
  htmlExport(sourceUri, offline) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.htmlExport({ offline }).then((dest) => {
        void import_coc18.window.showInformationMessage(`File ${import_path.default.basename(dest)} was created at path: ${dest}`);
      }).catch((error) => {
        void import_coc18.window.showErrorMessage(error.toString());
      });
    }
  }
  chromeExport(sourceUri, type) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.chromeExport({ fileType: type, openFileAfterGeneration: true }).then((dest) => {
        void import_coc18.window.showInformationMessage(`File ${import_path.default.basename(dest)} was created at path: ${dest}`);
      }).catch((error) => {
        void import_coc18.window.showErrorMessage(error.toString());
      });
    }
  }
  princeExport(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.princeExport({ openFileAfterGeneration: true }).then((dest) => {
        if (dest.endsWith("?print-pdf")) {
          void import_coc18.window.showInformationMessage(`Please copy and open the link: { ${dest.replace(/_/g, "\\_")} } in Chrome then Print as Pdf.`);
        } else {
          void import_coc18.window.showInformationMessage(`File ${import_path.default.basename(dest)} was created at path: ${dest}`);
        }
      }).catch((error) => {
        void import_coc18.window.showErrorMessage(error.toString());
      });
    }
  }
  eBookExport(sourceUri, fileType) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.eBookExport({ fileType, runAllCodeChunks: false }).then((dest) => {
        void import_coc18.window.showInformationMessage(`eBook ${import_path.default.basename(dest)} was created as path: ${dest}`);
      }).catch((error) => {
        void import_coc18.window.showErrorMessage(error.toString());
      });
    }
  }
  pandocExport(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.pandocExport({ openFileAfterGeneration: true }).then((dest) => {
        void import_coc18.window.showInformationMessage(`Document ${import_path.default.basename(dest)} was created as path: ${dest}`);
      }).catch((error) => {
        void import_coc18.window.showErrorMessage(error.toString());
      });
    }
  }
  markdownExport(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.markdownExport({}).then((dest) => {
        void import_coc18.window.showInformationMessage(`Document ${import_path.default.basename(dest)} was created as path: ${dest}`);
      }).catch((error) => {
        void import_coc18.window.showErrorMessage(error.toString());
      });
    }
  }
  cacheCodeChunkResult(sourceUri, id, result) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.cacheCodeChunkResult(id, result);
    }
  }
  runCodeChunk(sourceUri, codeChunkId) {
    const engine = this.getEngine(sourceUri);
    logger.prettyPrint(sourceUri.toString(), codeChunkId);
    if (engine) {
      engine.runCodeChunk(codeChunkId).then(() => {
        this.updateMarkdown(sourceUri);
      }).catch(logger.error);
    }
  }
  runAllCodeChunks(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.runCodeChunks().then(() => {
        this.updateMarkdown(sourceUri);
      }).catch(logger.error);
    }
  }
  update(sourceUri) {
    if (!this.config.liveUpdate || !this.getPreview(sourceUri)) {
      return;
    }
    if (!this.waiting) {
      this.waiting = true;
      setTimeout(() => {
        this.waiting = false;
        this.updateMarkdown(sourceUri);
      }, 300);
    }
  }
  updateConfiguration() {
    const newConfig = MarkdownPreviewEnhancedConfig.getCurrentConfig();
    if (!this.config.isEqualTo(newConfig)) {
      if (this.config.singlePreview !== newConfig.singlePreview) {
        this.closeAllPreviews(this.config.singlePreview);
        this.config = newConfig;
      } else {
        this.config = newConfig;
        for (const fsPath in this.engineMaps) {
          if (Object.prototype.hasOwnProperty.call(this.engineMaps, fsPath)) {
            const engine = this.engineMaps[fsPath];
            engine.updateConfiguration(newConfig);
          }
        }
        this.refreshAllPreviews();
      }
    }
  }
  openImageHelper(sourceUri) {
    if (sourceUri.scheme === "markdown-preview-enhanced") {
      return import_coc18.window.showWarningMessage("Please focus a markdown file.");
    } else if (!this.isPreviewOn(sourceUri)) {
      return import_coc18.window.showWarningMessage("Please open preview first.");
    } else {
      return this.previewPostMessage(sourceUri, {
        command: "openImageHelper"
      });
    }
  }
};
function useSinglePreview() {
  const config = import_coc18.workspace.getConfiguration("markdown-preview-enhanced");
  return config.get("singlePreview");
}
function getPreviewUri(uri) {
  if (uri.scheme === "markdown-preview-enhanced") {
    return uri;
  }
  let previewUri;
  if (useSinglePreview()) {
    previewUri = uri.with({
      scheme: "markdown-preview-enhanced",
      path: "single-preview.rendered"
    });
  } else {
    previewUri = uri.with({
      scheme: "markdown-preview-enhanced",
      path: `${uri.path}.rendered`,
      query: uri.toString()
    });
  }
  return previewUri;
}
function isMarkdownFile(document) {
  const uri = import_coc18.Uri.parse(document.uri);
  return document.languageId === "markdown" && uri.scheme !== "markdown-preview-enhanced";
}

// src/index.ts
var editorScrollDelay = Date.now();
async function openInVim(uri, type) {
  const nvim = import_coc19.workspace.nvim;
  const escapedPath = await import_coc19.workspace.nvim.call("fnameescape", [
    uri.fsPath
  ]);
  nvim.pauseNotification();
  if (type === "vsplit") {
    nvim.command(`vsplit ${escapedPath}`, true);
  } else {
    nvim.command(`edit ${escapedPath}`, true);
  }
  if (import_coc19.workspace.isVim) {
    nvim.command("redraw", true);
  }
  await nvim.resumeNotification();
}
function activate(context) {
  const contentProvider = new MarkdownPreviewEnhancedView(context);
  async function openPreview(openURL, uri) {
    const doc = await import_coc19.workspace.document;
    let resource = uri;
    if (!(resource instanceof import_coc19.Uri)) {
      resource = import_coc19.Uri.parse(doc.uri);
    }
    await contentProvider.initPreview(resource, doc, openURL);
  }
  function toggleScrollSync() {
    const config = import_coc19.workspace.getConfiguration("markdown-preview-enhanced");
    const scrollSync = !config.get("scrollSync");
    config.update("scrollSync", scrollSync, true);
    contentProvider.updateConfiguration();
    if (scrollSync) {
      void import_coc19.window.showInformationMessage("Scroll Sync is enabled");
    } else {
      void import_coc19.window.showInformationMessage("Scroll Sync is disabled");
    }
  }
  function toggleLiveUpdate() {
    const config = import_coc19.workspace.getConfiguration("markdown-preview-enhanced");
    const liveUpdate = !config.get("liveUpdate");
    config.update("liveUpdate", liveUpdate, true);
    contentProvider.updateConfiguration();
    if (liveUpdate) {
      void import_coc19.window.showInformationMessage("Live Update is enabled");
    } else {
      void import_coc19.window.showInformationMessage("Live Update is disabled");
    }
  }
  function toggleBreakOnSingleNewLine() {
    const config = import_coc19.workspace.getConfiguration("markdown-preview-enhanced");
    const breakOnSingleNewLine = !config.get("breakOnSingleNewLine");
    config.update("breakOnSingleNewLine", breakOnSingleNewLine, true);
    contentProvider.updateConfiguration();
    if (breakOnSingleNewLine) {
      void import_coc19.window.showInformationMessage("Break On Single New Line is enabled");
    } else {
      void import_coc19.window.showInformationMessage("Break On Single New Line is disabled");
    }
  }
  async function customizeCSS() {
    const globalStyleLessFile = import_mume3.utility.addFileProtocol(import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./style.less"));
    await openInVim(import_coc19.Uri.parse(globalStyleLessFile), "vsplit");
  }
  async function openMermaidConfig() {
    const mermaidConfigFilePath = import_mume3.utility.addFileProtocol(import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./mermaid_config.js"));
    await openInVim(import_coc19.Uri.parse(mermaidConfigFilePath), "vsplit");
  }
  async function openMathJaxConfig() {
    const mathjaxConfigFilePath = import_mume3.utility.addFileProtocol(import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./mathjax_config.js"));
    await openInVim(import_coc19.Uri.parse(mathjaxConfigFilePath), "vsplit");
  }
  async function openKaTeXConfig() {
    const katexConfigFilePath = import_mume3.utility.addFileProtocol(import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./katex_config.js"));
    await openInVim(import_coc19.Uri.parse(katexConfigFilePath), "vsplit");
  }
  async function extendParser() {
    const parserConfigPath = import_mume3.utility.addFileProtocol(import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./parser.js"));
    await openInVim(import_coc19.Uri.parse(parserConfigPath), "vsplit");
  }
  async function showUploadedImages() {
    const imageHistoryFilePath = import_mume3.utility.addFileProtocol(import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./image_history.md"));
    await openInVim(import_coc19.Uri.parse(imageHistoryFilePath), "vsplit");
  }
  async function cursorPosition() {
    const win = await import_coc19.workspace.nvim.window;
    const cursor = await win.cursor;
    return import_coc19.Position.create(cursor[0], cursor[1]);
  }
  async function insertNewSlide() {
    const doc = await import_coc19.workspace.document;
    await doc.applyEdits([
      import_coc19.TextEdit.insert(await cursorPosition(), "<!-- slide -->\n")
    ]);
  }
  async function insertPagebreak() {
    const doc = await import_coc19.workspace.document;
    await doc.applyEdits([
      import_coc19.TextEdit.insert(await cursorPosition(), "<!-- pagebreak -->\n")
    ]);
  }
  async function createTOC() {
    const doc = await import_coc19.workspace.document;
    await doc.applyEdits([
      import_coc19.TextEdit.insert(await cursorPosition(), '\n<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->\n')
    ]);
  }
  async function insertTable() {
    const doc = await import_coc19.workspace.document;
    await doc.applyEdits([
      import_coc19.TextEdit.insert(await cursorPosition(), `|   |   |
|---|---|
|   |   |
`)
    ]);
  }
  async function openImageHelper() {
    await contentProvider.openImageHelper(import_coc19.Uri.parse((await import_coc19.workspace.document).uri));
  }
  function webviewFinishLoading(uri) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.updateMarkdown(sourceUri);
  }
  async function insertImageUrl(uri, imageUrl) {
    const doc = import_coc19.workspace.getDocument(uri);
    if (doc && isMarkdownFile(doc.textDocument)) {
      await doc.applyEdits([
        import_coc19.TextEdit.insert(await cursorPosition(), `![enter image description here](${imageUrl})`)
      ]);
    }
  }
  function refreshPreview(uri) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.refreshPreview(sourceUri);
  }
  function openInBrowser(uri) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.openInBrowser(sourceUri);
  }
  function htmlExport(uri, offline) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.htmlExport(sourceUri, offline);
  }
  function chromeExport(uri, type) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.chromeExport(sourceUri, type);
  }
  function princeExport(uri) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.princeExport(sourceUri);
  }
  function eBookExport(uri, fileType) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.eBookExport(sourceUri, fileType);
  }
  function pandocExport(uri) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.pandocExport(sourceUri);
  }
  function markdownExport(uri) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.markdownExport(sourceUri);
  }
  function cacheCodeChunkResult(uri, id, result) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.cacheCodeChunkResult(sourceUri, id, result);
  }
  function runCodeChunk(uri, codeChunkId) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.runCodeChunk(sourceUri, codeChunkId);
  }
  function runAllCodeChunks(uri) {
    const sourceUri = import_coc19.Uri.parse(uri);
    contentProvider.runAllCodeChunks(sourceUri);
  }
  async function runAllCodeChunksCommand() {
    const doc = await import_coc19.workspace.document;
    if (!isMarkdownFile(doc.textDocument)) {
      return;
    }
    const sourceUri = import_coc19.Uri.parse(doc.uri);
    const previewUri = getPreviewUri(sourceUri);
    if (!previewUri) {
      return;
    }
    contentProvider.previewPostMessage(sourceUri, {
      command: "runAllCodeChunks"
    });
  }
  async function runCodeChunkCommand() {
    const doc = await import_coc19.workspace.document;
    if (!isMarkdownFile(doc.textDocument)) {
      return;
    }
    const sourceUri = import_coc19.Uri.parse(doc.uri);
    const previewUri = getPreviewUri(sourceUri);
    if (!previewUri) {
      return;
    }
    contentProvider.previewPostMessage(sourceUri, {
      command: "runCodeChunk"
    });
  }
  async function syncPreview() {
    const doc = await import_coc19.workspace.document;
    if (!isMarkdownFile(doc.textDocument)) {
      return;
    }
    const sourceUri = import_coc19.Uri.parse(doc.uri);
    contentProvider.previewPostMessage(sourceUri, {
      command: "changeTextEditorSelection",
      line: (await cursorPosition()).line,
      forced: true
    });
  }
  async function clickTagA(uri, href) {
    const util2 = getWebviewAPI().util;
    const curDoc = await import_coc19.workspace.document;
    href = decodeURIComponent(href);
    if (!href) {
      return;
    }
    if ([".pdf", ".xls", ".xlsx", ".doc", ".ppt", ".docx", ".pptx"].indexOf(import_path2.default.extname(uri)) >= 0) {
      util2.openUri(href);
    } else {
      const url = new import_url.URL(href);
      const openType = curDoc.uri === uri ? "edit" : "vsplit";
      await openInVim(import_coc19.Uri.parse(url.pathname), openType);
    }
  }
  async function clickTaskListCheckbox(uri, dataLine) {
    const doc = import_coc19.workspace.getDocument(uri);
    if (!doc || !isMarkdownFile(doc.textDocument)) {
      return;
    }
    const dataLineNum = parseInt(dataLine, 10);
    let line = doc.getline(dataLineNum);
    if (line.match(/\[ \]/)) {
      line = line.replace("[ ]", "[x]");
    } else {
      line = line.replace(/\[[xX]\]/, "[ ]");
    }
    await doc.applyEdits([
      import_coc19.TextEdit.replace(import_coc19.Range.create(import_coc19.Position.create(dataLineNum, 0), import_coc19.Position.create(dataLineNum, line.length)), line)
    ]);
  }
  function setPreviewTheme(_uri, theme) {
    const config = import_coc19.workspace.getConfiguration("markdown-preview-enhanced");
    config.update("previewTheme", theme, true);
  }
  context.subscriptions.push(import_coc19.workspace.onDidSaveTextDocument(logger.asyncCatch((document) => {
    if (isMarkdownFile(document)) {
      contentProvider.updateMarkdown(import_coc19.Uri.parse(document.uri), true);
    }
  })), import_coc19.workspace.onDidChangeTextDocument(logger.asyncCatch((event) => {
    const doc = import_coc19.workspace.getDocument(event.textDocument.uri);
    if (doc && isMarkdownFile(doc.textDocument)) {
      contentProvider.update(import_coc19.Uri.parse(doc.uri));
    }
  })), import_coc19.workspace.onDidChangeConfiguration(logger.asyncCatch(() => {
    contentProvider.updateConfiguration();
  })), import_coc19.events.on("CursorMoved", logger.asyncCatch(async (bufnr) => {
    const doc = import_coc19.workspace.getDocument(bufnr);
    if (doc && isMarkdownFile(doc.textDocument)) {
      if (Date.now() < editorScrollDelay) {
        return;
      }
      const sourceUri = import_coc19.Uri.parse(doc.uri);
      const win = await import_coc19.workspace.nvim.window;
      const height = await win.height;
      if (!height) {
        return void 0;
      }
      const [line] = await win.cursor;
      contentProvider.previewPostMessage(sourceUri, {
        command: "changeTextEditorSelection",
        line
      });
    }
  })), import_coc19.events.on("BufEnter", logger.asyncCatch(async () => {
    const doc = await import_coc19.workspace.document;
    if (isMarkdownFile(doc.textDocument)) {
      const sourceUri = import_coc19.Uri.parse(doc.uri);
      const config = import_coc19.workspace.getConfiguration("markdown-preview-enhanced");
      const automaticallyShowPreviewOfMarkdownBeingEdited = config.get("automaticallyShowPreviewOfMarkdownBeingEdited");
      const isUsingSinglePreview = config.get("singlePreview");
      if (contentProvider.isPreviewOn(sourceUri)) {
        if (isUsingSinglePreview && !contentProvider.previewHasTheSameSingleSourceUri(sourceUri)) {
          await contentProvider.initPreview(sourceUri, doc, false);
        } else if (!isUsingSinglePreview) {
          const previewPanel = contentProvider.getPreview(sourceUri);
          if (previewPanel) {
            previewPanel.reveal({ openURL: false });
          }
        }
      } else if (automaticallyShowPreviewOfMarkdownBeingEdited) {
        await openPreview(true, sourceUri);
      }
    }
  })));
  const registerCommand = (cmd, impl) => import_coc19.commands.registerCommand(cmd, logger.asyncCatch(impl));
  context.subscriptions.push(registerCommand("markdown-preview-enhanced.openPreview", logger.asyncCatch(() => openPreview(true))), registerCommand("markdown-preview-enhanced.openPreviewBackground", logger.asyncCatch(() => openPreview(false))), registerCommand("markdown-preview-enhanced.toggleScrollSync", toggleScrollSync), registerCommand("markdown-preview-enhanced.toggleLiveUpdate", toggleLiveUpdate), registerCommand("markdown-preview-enhanced.toggleBreakOnSingleNewLine", toggleBreakOnSingleNewLine), registerCommand("markdown-preview-enhanced.openImageHelper", logger.asyncCatch(openImageHelper)), registerCommand("markdown-preview-enhanced.runAllCodeChunks", logger.asyncCatch(runAllCodeChunksCommand)), registerCommand("markdown-preview-enhanced.runCodeChunk", logger.asyncCatch(runCodeChunkCommand)), registerCommand("markdown-preview-enhanced.syncPreview", logger.asyncCatch(syncPreview)), registerCommand("markdown-preview-enhanced.customizeCss", logger.asyncCatch(customizeCSS)), registerCommand("markdown-preview-enhanced.openMermaidConfig", logger.asyncCatch(openMermaidConfig)), registerCommand("markdown-preview-enhanced.openMathJaxConfig", logger.asyncCatch(openMathJaxConfig)), registerCommand("markdown-preview-enhanced.openKaTeXConfig", logger.asyncCatch(openKaTeXConfig)), registerCommand("markdown-preview-enhanced.extendParser", logger.asyncCatch(extendParser)), registerCommand("markdown-preview-enhanced.showUploadedImages", logger.asyncCatch(showUploadedImages)), registerCommand("markdown-preview-enhanced.insertNewSlide", logger.asyncCatch(insertNewSlide)), registerCommand("markdown-preview-enhanced.insertTable", logger.asyncCatch(insertTable)), registerCommand("markdown-preview-enhanced.insertPagebreak", logger.asyncCatch(insertPagebreak)), registerCommand("markdown-preview-enhanced.createTOC", logger.asyncCatch(createTOC)), registerCommand("_mume.revealLine", logger.asyncCatch(revealLine)), registerCommand("_mume.insertImageUrl", logger.asyncCatch(insertImageUrl)), registerCommand("_mume.pasteImageFile", logger.asyncCatch(pasteImageFile)), registerCommand("_mume.uploadImageFile", logger.asyncCatch(uploadImageFile)), registerCommand("_mume.refreshPreview", logger.asyncCatch(refreshPreview)), registerCommand("_mume.openInBrowser", logger.asyncCatch(openInBrowser)), registerCommand("_mume.htmlExport", logger.asyncCatch(htmlExport)), registerCommand("_mume.chromeExport", logger.asyncCatch(chromeExport)), registerCommand("_mume.princeExport", logger.asyncCatch(princeExport)), registerCommand("_mume.eBookExport", logger.asyncCatch(eBookExport)), registerCommand("_mume.pandocExport", logger.asyncCatch(pandocExport)), registerCommand("_mume.markdownExport", logger.asyncCatch(markdownExport)), registerCommand("_mume.webviewFinishLoading", logger.asyncCatch(webviewFinishLoading)), registerCommand("_mume.cacheCodeChunkResult", logger.asyncCatch(cacheCodeChunkResult)), registerCommand("_mume.runCodeChunk", logger.asyncCatch(runCodeChunk)), registerCommand("_mume.runAllCodeChunks", logger.asyncCatch(runAllCodeChunks)), registerCommand("_mume.clickTagA", logger.asyncCatch(clickTagA)), registerCommand("_mume.clickTaskListCheckbox", logger.asyncCatch(clickTaskListCheckbox)), registerCommand("_mume.showUploadedImageHistory", logger.asyncCatch(showUploadedImages)), registerCommand("_mume.setPreviewTheme", logger.asyncCatch(setPreviewTheme)));
}
async function revealLine(uri, line) {
  const doc = import_coc19.workspace.getDocument(uri);
  if (doc && isMarkdownFile(doc.textDocument)) {
    const mode = await import_coc19.workspace.nvim.mode;
    if (mode.mode !== "n") {
      return;
    }
    const sourceLine = Math.min(Math.floor(line), doc.lineCount - 1);
    const fraction = line - sourceLine;
    const text = doc.getline(sourceLine);
    const start = Math.floor(fraction * text.length);
    const winnr = await import_coc19.workspace.nvim.call("bufwinnr", [doc.bufnr]);
    if (winnr === -1)
      return;
    const winid = await import_coc19.workspace.nvim.call("win_getid", [winnr]);
    const win = import_coc19.workspace.nvim.createWindow(winid);
    if (!await win.valid)
      return;
    editorScrollDelay = Date.now() + 500;
    await win.setCursor([sourceLine + 1, start]);
    editorScrollDelay = Date.now() + 500;
  }
}
function deactivate() {
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
