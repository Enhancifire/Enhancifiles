"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
exports.__esModule = true;
exports.testSpec = exports.createMultipleEditBuildFunction = exports.createBuildFunction = void 0;
var jscodeshift = require("jscodeshift");
var range = require("../../range");
function createBuildFunction(fixer) {
    var foo = createMultipleEditBuildFunction(fixer);
    return function buildEditResponse(source, r, parser) {
        return foo(source, r, parser)[0];
    };
}
exports.createBuildFunction = createBuildFunction;
function createMultipleEditBuildFunction(fixer) {
    return function buildEditResponse(source, r, parser) {
        var api = jscodeshift.withParser(parser || 'babylon');
        var params = {
            j: api,
            ast: api(source),
            selection: r,
            logger: console,
            config: { packages: [] }
        };
        var action = fixer.suggestCodeAction(params);
        if (!action) {
            throw new Error('No suggested action returned from fixer');
        }
        var edit = fixer.createEdit({
            j: api,
            ast: api(source),
            data: action.data,
            logger: console
        });
        if (!edit) {
            throw new Error('No edit returned from fixer');
        }
        var edits = edit instanceof Array ? edit : [edit];
        return edits.map(function (edit) { return ({
            title: action.title,
            newText: edit.newText,
            range: edit.range
        }); });
    };
}
exports.createMultipleEditBuildFunction = createMultipleEditBuildFunction;
function testSpec(fixer, specSourceText) {
    var buildEditResponse = createMultipleEditBuildFunction(fixer);
    describe('specs', function () {
        specSourceText
            .split(/^={3,}/m)
            .map(function (t) { return t.trim(); })
            .filter(function (t) { return t; })
            .map(parseSpec)
            .forEach(function (spec) {
            var run = spec.only ? it.only : it;
            run(spec.name, function () {
                var edits = buildEditResponse(spec.source, spec.range, spec.parser);
                var result = applyEdits(spec.source, edits);
                expect(result.trimRight()).toBe(spec.target.trimRight());
            });
        });
    });
}
exports.testSpec = testSpec;
function parseIntWithDefault(s, def) {
    var n = parseInt(s);
    if (Number.isNaN(n)) {
        return def;
    }
    return n;
}
function parseSpec(txt) {
    var _a = __read(txt.split(/\n\-\-\-\n/m), 3), setupText = _a[0], source = _a[1], target = _a[2];
    var setup = setupText
        .split('\n')
        .map(function (o) { return o.trim().split(':'); })
        .reduce(function (acc, _a) {
        var _b;
        var _c = __read(_a, 2), name = _c[0], value = _c[1];
        return (__assign(__assign({}, acc), (_b = {}, _b[name.trim()] = value.trim(), _b)));
    }, {});
    var column = parseInt(setup.column);
    if (!setup.column || Number.isNaN(column)) {
        throw new Error('Setup should have column defined as integer');
    }
    if (!setup.name) {
        throw new Error('Setup should have name defined');
    }
    var line = parseIntWithDefault(setup.line, 1);
    var endLine = parseIntWithDefault(setup.endLine, line);
    var endColumn = parseIntWithDefault(setup.endColumn, column);
    return {
        only: setup.only === 'true',
        source: source,
        target: target,
        name: setup.name,
        range: range.create(line, column, endLine, endColumn),
        parser: setup.parser || 'babylon'
    };
}
function positionToOffset(t, p) {
    var rows = t.split('\n');
    var offset = 0;
    for (var i = 0; i < p.line - 1; i++) {
        offset += rows[i].length + 1;
    }
    offset += p.column;
    return offset;
}
function applyEdit(source, edit) {
    var startOffset = positionToOffset(source, edit.range.start);
    var endOffset = positionToOffset(source, edit.range.end);
    var b = source.slice(0, startOffset) + edit.newText + source.slice(endOffset);
    return b;
}
function applyEdits(source, edits) {
    return edits.reduce(function (s, edit) { return applyEdit(s, edit); }, source);
}
