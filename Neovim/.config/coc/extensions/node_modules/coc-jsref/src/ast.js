"use strict";
exports.__esModule = true;
exports.negateExpression = exports.isOnPosition = exports.cloneNode = exports.findLastNode = exports.findFirstNode = exports.find = exports.firstNode = void 0;
function firstNode(c) {
    return c.nodes()[0] || null;
}
exports.firstNode = firstNode;
function find(ast, type, filter) {
    return ast.find(type, filter);
}
exports.find = find;
function findFirstNode(ast, type, filter) {
    var coll = ast.find(type, filter);
    return firstNode(coll);
}
exports.findFirstNode = findFirstNode;
function findLastNode(ast, type, filter) {
    var coll = ast.find(type, filter);
    var nodes = coll.nodes();
    return nodes[nodes.length - 1] || null;
}
exports.findLastNode = findLastNode;
function cloneNode(j, node) {
    return j(node).nodes()[0];
}
exports.cloneNode = cloneNode;
function isOnPosition(n, pos) {
    if (!n.loc) {
        return false;
    }
    return n.loc.start.line === pos.line && n.loc.start.column === pos.column;
}
exports.isOnPosition = isOnPosition;
function negateExpression(j, expr) {
    // 1. !a => a
    if (j.UnaryExpression.check(expr) && expr.operator === '!') {
        return expr.argument;
    }
    // 2. invert binary operators
    var operatorMap = {
        '<': '>=',
        '>': '<=',
        '>=': '<',
        '<=': '>',
        '!=': '==',
        '==': '!=',
        '!==': '===',
        '===': '!=='
    };
    if (j.BinaryExpression.check(expr) && operatorMap[expr.operator]) {
        expr.operator = operatorMap[expr.operator];
        return expr;
    }
    // Fallback: a => !a
    return j.unaryExpression('!', expr, true);
}
exports.negateExpression = negateExpression;
