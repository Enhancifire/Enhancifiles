/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE.md in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerComposeCompletionItemProvider = void 0;
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const dockerComposeKeyInfo_1 = tslib_1.__importDefault(require("./dockerComposeKeyInfo"));
const suggestSupportHelper_1 = require("../utils/suggestSupportHelper");
class DockerComposeCompletionItemProvider {
    async provideCompletionItems(textDocument, position, token, context) {
        const hub = new suggestSupportHelper_1.SuggestSupportHelper();
        // Determine the schema version of the current compose file,
        // based on the existence of a top-level "version" property.
        const versionMatch = textDocument.getText().match(/^version:\s*(["'])(\d+(\.\d)?)\1/im);
        const version = versionMatch ? versionMatch[2] : "1";
        const document = coc_nvim_1.workspace.getDocument(textDocument.uri);
        // Get the line where intellisense was invoked on (e.g. 'image: u').
        const line = await coc_nvim_1.workspace.getLine(textDocument.uri, position.line);
        if (line.length === 0) {
            // empty line
            return Promise.resolve(this.suggestKeys('', version));
        }
        const range = document.getWordRangeAtPosition(position);
        // Get the text where intellisense was invoked on (e.g. 'u').
        const word = range && textDocument.getText(range);
        const textBefore = line.substring(0, position.character);
        if (/^\s*[\w_]*$/.test(textBefore)) {
            // on the first token
            return Promise.resolve(this.suggestKeys(word, version));
        }
        // Matches strings like: 'image: "ubuntu'
        const imageTextWithQuoteMatchYaml = textBefore.match(/^\s*image\s*:\s*"([^"]*)$/);
        if (imageTextWithQuoteMatchYaml) {
            const imageText = imageTextWithQuoteMatchYaml[1];
            return hub.suggestImages(imageText);
        }
        // Matches strings like: 'image: ubuntu'
        const imageTextWithoutQuoteMatch = textBefore.match(/^\s*image\s*:\s*([\w:/]*)/);
        if (imageTextWithoutQuoteMatch) {
            const imageText = imageTextWithoutQuoteMatch[1];
            return hub.suggestImages(imageText);
        }
        return Promise.resolve([]);
    }
    suggestKeys(word, version) {
        // Attempt to grab the keys for the requested schema version,
        // otherwise, fall back to showing a composition of all possible keys.
        const keys = dockerComposeKeyInfo_1.default[`v${version}`] || dockerComposeKeyInfo_1.default.All;
        return Object.keys(keys).map(ruleName => {
            const completionItem = { label: ruleName };
            completionItem.kind = coc_nvim_1.CompletionItemKind.Keyword;
            completionItem.insertText = ruleName + ': ';
            completionItem.documentation = keys[ruleName];
            return completionItem;
        });
    }
}
exports.DockerComposeCompletionItemProvider = DockerComposeCompletionItemProvider;
//# sourceMappingURL=dockerComposeCompletionItemProvider.js.map