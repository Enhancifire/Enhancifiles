/*! @gera2ld/format-json v0.2.3 | MIT License */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

exports.ItemTypes = void 0;

(function (ItemTypes) {
  ItemTypes["MULTILINE"] = "MULTILINE";
  ItemTypes["SINGLELINE"] = "SINGLELINE";
  ItemTypes["KEY"] = "KEY";
  ItemTypes["COMMA"] = "COMMA";
  ItemTypes["BR"] = "BR";
})(exports.ItemTypes || (exports.ItemTypes = {}));

const COMMA = {
  type: exports.ItemTypes.COMMA,
  value: ','
};
const BR = {
  type: exports.ItemTypes.BR,
  value: '\n'
};
const charMapBase = {
  '\\': '\\\\',
  '\r': '\\r',
  '\t': '\\t'
};

const charMapQuote = _extends({}, charMapBase, {
  '\'': '\\\'',
  '\n': '\\n'
});

const charMapTemplate = _extends({}, charMapBase, {
  '`': '\\`'
});

function quoteString(str, {
  quote,
  quoteAsNeeded,
  template
}) {
  if (template && /\n/.test(str)) {
    const quoted = str.replace(/[\\`\r\t]/g, m => charMapTemplate[m]);
    return `\`${quoted}\``;
  }

  if (!quoteAsNeeded || /\W/.test(str)) {
    const re = new RegExp(`[\\\\\\r\\n\\t${quote}]`, 'g');
    const quoted = str.replace(re, m => charMapQuote[m]);
    return quote + quoted + quote;
  }

  return str;
}

function getSpace(level, indent) {
  return {
    type: 'space',
    value: ' '.repeat(indent * level)
  };
}

function renderArray(data, options, path = []) {
  const level = path.length;
  const arr = [];
  const ret = {
    type: exports.ItemTypes.MULTILINE,
    separator: [COMMA],
    data: arr,
    path
  };
  arr.push({
    value: '['
  });

  if (data.length) {
    const rendered = data.map((item, i) => render(item, options, [...path, i]));
    arr.push(...(options.indent ? [BR] : []), getSpace(level + 1, options.indent), ...join(rendered, options, level + 1), ...(options.indent ? [BR] : []), getSpace(level, options.indent));
  } else {
    ret.type = exports.ItemTypes.SINGLELINE;
  }

  arr.push({
    value: ']'
  });
  return ret;
}

function renderObject(data, options, path = []) {
  const level = path.length;
  const arr = [];
  const ret = {
    type: exports.ItemTypes.MULTILINE,
    separator: [COMMA],
    data: arr,
    path
  };
  arr.push({
    value: '{'
  });
  const entries = typeof options.entries === 'function' ? options.entries(data) : Object.entries(data).sort((a, b) => {
    if (a[0] < b[0]) return -1;
    if (a[0] > b[0]) return 1;
    return 0;
  });
  const rendered = entries.map(([key, value, displayKey]) => {
    const subpath = [...path, key];
    const keyItem = {
      type: exports.ItemTypes.KEY,
      data: [{
        value: quoteString(displayKey != null ? displayKey : key, options),
        type: 'key'
      }],
      separator: [{
        value: ':'
      }],
      path: subpath
    };
    options.onData == null ? void 0 : options.onData(keyItem);
    return [keyItem, render(value, options, subpath)];
  }).reduce((res, cur) => [...res, ...cur], []);

  if (rendered.length) {
    arr.push(...(options.indent ? [BR] : []), getSpace(level + 1, options.indent), ...join(rendered, options, level + 1), ...(options.indent ? [BR] : []), getSpace(level, options.indent));
  } else {
    ret.type = exports.ItemTypes.SINGLELINE;
  }

  arr.push({
    value: '}'
  });
  return ret;
}

function render(data, options, path = []) {
  let result;

  if (Array.isArray(data)) {
    result = renderArray(data, options, path);
  } else if (data === null) {
    result = {
      type: exports.ItemTypes.SINGLELINE,
      separator: [COMMA],
      data: [{
        value: `${data}`,
        type: 'null'
      }],
      path
    };
  } else if (typeof data === 'object') {
    result = renderObject(data, options, path);
  } else {
    result = {
      type: exports.ItemTypes.SINGLELINE,
      separator: [COMMA],
      data: [{
        value: typeof data === 'string' ? quoteString(data, _extends({}, options, {
          quoteAsNeeded: false
        })) : `${data}`
      }],
      path
    };
  }

  options.onData == null ? void 0 : options.onData(result);
  return result;
}

function join(rendered, options, level) {
  const arr = [];

  for (let i = 0; i < rendered.length; i += 1) {
    const item = rendered[i];
    const next = rendered[i + 1];
    if (item.data) arr.push(...item.data); // trailing separators

    if (item.separator && (next || options.trailing)) {
      arr.push(...item.separator);
    }

    if (next) {
      if (item.type === exports.ItemTypes.KEY) {
        if (options.indent) arr.push({
          value: ' '
        });
      } else {
        arr.push(...(options.indent ? [BR] : []), getSpace(level, options.indent));
      }
    }
  }

  return arr;
}

const defaultRenderOptions = {
  indent: 0,
  quoteAsNeeded: false,
  quote: '"',
  trailing: false,
  template: false
};
function format(data, options) {
  const renderOptions = _extends({}, defaultRenderOptions, options);

  const rendered = render(data, renderOptions);
  return (rendered.data || []).map(({
    value
  }) => `${value}`).join('');
}

exports.defaultRenderOptions = defaultRenderOptions;
exports.format = format;
exports.render = render;
