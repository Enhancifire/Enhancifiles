/*! coc-format-json v0.2.1 | MIT License */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var coc_nvim = require('coc.nvim');
var formatJson$1 = require('@gera2ld/format-json');
var JSON5 = require('json5');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var JSON5__default = /*#__PURE__*/_interopDefaultLegacy(JSON5);

const optionsJSON = {
  indent: 2,
  quote: '"',
  quoteAsNeeded: false,
  trailing: false,
  template: false
};
const optionsJS = {
  indent: 2,
  quote: '\'',
  quoteAsNeeded: true,
  trailing: true,
  template: true
};

async function getContent(hasSelection = false) {
  const doc = await coc_nvim.workspace.document;
  const range = await coc_nvim.workspace.getSelectedRange('v', doc);

  if (hasSelection) {
    return {
      range,
      text: doc.textDocument.getText(range)
    };
  }

  return {
    text: doc.textDocument.getText()
  };
}

function getOptions(args) {
  const rawOptions = {};
  let key;

  for (const arg of args) {
    if (arg.startsWith('--')) {
      var _value;

      let value;
      [key, value] = arg.slice(2).split('=');
      key = key.replace(/-(\w)/g, (_m, g) => g.toUpperCase());
      rawOptions[key] = (_value = value) != null ? _value : 'true';
    } else if (key) {
      rawOptions[key] = arg;
    }
  }

  let options;

  if (rawOptions.presetJs === 'true') {
    options = _extends__default({}, optionsJS);
  } else {
    options = _extends__default({}, optionsJSON);
  }

  if (rawOptions.indent != null) options.indent = +rawOptions.indent;
  if (rawOptions.quote === '\'' || rawOptions.quote === '"') options.quote = rawOptions.quote;
  if (rawOptions.quoteAsNeeded != null) options.quoteAsNeeded = rawOptions.quoteAsNeeded === 'true';
  if (rawOptions.template != null) options.template = rawOptions.template === 'true';
  if (rawOptions.trailing != null) options.trailing = rawOptions.trailing === 'true';
  return options;
}

async function formatJson(content, options) {
  const formatted = formatJson$1.format(JSON5__default.parse(content.text), options);

  if (content.range) {
    const doc = await coc_nvim.workspace.document;
    doc.applyEdits([{
      range: content.range,
      newText: formatted
    }]);
  } else {
    const buffer = await coc_nvim.workspace.nvim.buffer;
    const [, last] = await coc_nvim.workspace.nvim.eval('getpos("$")');
    buffer.setLines(formatted.split('\n'), {
      start: 0,
      end: last
    });
  }
}

function activate(context) {
  context.subscriptions.push(coc_nvim.commands.registerCommand('formatJson', async (...args) => {
    await formatJson(await getContent(), getOptions(args));
  }));
  context.subscriptions.push(coc_nvim.commands.registerCommand('formatJson.selected', async (...args) => {
    await formatJson(await getContent(true), getOptions(args));
  }));
}

exports.activate = activate;
