'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fetch = require('node-fetch');
var util = require('util');
var WebSocket = require('ws');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);

function isString(value) {
    return typeof value === 'string';
}
function isError(value) {
    return value instanceof Error;
}
class DevLogger {
    constructor(name, defaultContext = '') {
        this.name = name;
        this.defaultContext = defaultContext;
    }
    trace(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    debug(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    info(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    warn(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    error(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    write(level, args) {
        if (level >= DevLogger.options.level &&
            (DevLogger.options.enabled.has('*') || DevLogger.options.enabled.has(this.name))) {
            const context = args.length >= 2 && isString(args[0]) && (isString(args[1]) || isError(args[1]))
                ? args.shift()
                : this.defaultContext;
            const message = `${Date.now()} ${level}  [${this.name}]${context ? ' (' + context + ')' : ''} ${this.inspect(args)}`;
            switch (level) {
                case "ERROR" /* ERROR */:
                    console.error(message);
                    break;
                case "WARN" /* WARN */:
                    console.warn(message);
                    break;
                default:
                    console.log(message);
                    break;
            }
        }
    }
    inspect(args) {
        return args.map((arg) => (typeof arg === 'object' && arg ? util.inspect(arg, true, null) : arg)).join(' ');
    }
}
DevLogger.options = {
    enabled: new Set(['*']),
    level: "TRACE" /* TRACE */,
};

const LOGGER = process.env.NODE_ENV !== 'production' ? new DevLogger('GrammarlyAuth') : null;
function toCookie(params) {
    return Object.entries(params)
        .map(([key, value]) => key + '=' + value + ';')
        .join(' ');
}
const UA = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36';
const BROWSER_HEADERS = {
    'User-Agent': UA,
    Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',
    'Accept-Language': 'en-GB,en-US;q=0.9,en;q=0.8',
    'Cache-Control': 'no-cache',
    Pragma: 'no-cache',
};
function cookieToObject(cookies) {
    return cookies
        .map((x) => x.split('='))
        .reduce((obj, [key, val]) => {
        obj[key] = val.split(';')[0];
        return obj;
    }, {});
}
async function getInitialCookie() {
    const response = await fetch__default['default']('https://www.grammarly.com/signin', {
        headers: {
            ...BROWSER_HEADERS,
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'same-origin',
            'Sec-Fetch-User': '?1',
            'Upgrade-Insecure-Requests': '1',
            Referer: 'https://www.grammarly.com/',
        },
        method: 'GET',
    });
    if (response.status < 300) {
        const cookies = response.headers.raw()['set-cookie'];
        const result = {
            raw: response.headers.get('Set-Cookie'),
            headers: cookies,
            parsed: cookieToObject(cookies),
        };
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.trace('Received container ID', result.parsed.gnar_containerId);
        return result;
    }
    try {
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.trace(`Cannot find container ID: ${response.status} - ${response.statusText}`, await response.text());
    }
    catch {
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.trace(`Cannot find container ID: ${response.status} - ${response.statusText}`);
    }
    return null;
}
function generateRedirectLocation() {
    return Buffer.from(JSON.stringify({
        type: '',
        location: `https://www.grammarly.com/`,
    })).toString('base64');
}
async function anonymous() {
    if (process.env.NODE_ENV !== 'production')
        LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.trace('Connecting anonymously');
    const cookie = await getInitialCookie();
    if (!cookie) {
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.error('Failed to get container ID');
        throw new Error('Authentication cannot be started.');
    }
    const response = await fetch__default['default']('https://auth.grammarly.com/v3/user/oranonymous?app=chromeExt&containerId=' + cookie.parsed.gnar_containerId, {
        method: 'GET',
        headers: {
            ...BROWSER_HEADERS,
            Accept: 'application/json',
            'X-Client-Type': 'extension-chrome',
            'X-Client-Version': '1.2.390-SNAPSHOT',
            'X-Container-ID': cookie.parsed.gnar_containerId,
            'x-csrf-token': cookie.parsed['csrf-token'],
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-site',
            Referer: 'https://www.grammarly.com/signin',
            Origin: 'https://www.grammarly.com',
            cookie: toCookie({
                gnar_containerId: cookie.parsed.gnar_containerId,
                redirect_location: generateRedirectLocation(),
                firefox_freemium: 'true',
                funnelType: 'free',
                browser_info: cookie.parsed.browser_info,
            }),
        },
    });
    if (response.ok) {
        const cookies = response.headers.raw()['set-cookie'];
        try {
            const data = await response.json();
            if (process.env.NODE_ENV !== 'production')
                LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.info('Authentication successful: ' + data.id);
            return {
                isAnonymous: true,
                token: toCookie({
                    ...cookie.parsed,
                    ...cookieToObject(cookies),
                }),
                container: cookie.parsed.gnar_containerId,
                username: 'anonymous',
            };
        }
        catch { }
    }
    try {
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.error(`anonymous connection failed: ${response.status} - ${response.statusText}`, await response.text());
    }
    catch {
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.error(`anonymous connection failed: ${response.status} - ${response.statusText}`);
    }
    throw new Error(response.statusText);
}
async function authenticate(username, password) {
    if (process.env.NODE_ENV !== 'production')
        LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.trace('Connecting as ' + username);
    const cookie = await getInitialCookie();
    if (!cookie) {
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.error('Failed to get container ID');
        throw new Error('Authentication cannot be started.');
    }
    const headers = {
        accept: 'application/json',
        'accept-language': BROWSER_HEADERS['Accept-Language'],
        'content-type': 'application/json',
        'user-agent': BROWSER_HEADERS['User-Agent'],
        'x-client-type': 'funnel',
        'x-client-version': '1.2.2026',
        'x-container-id': cookie.parsed.gnar_containerId,
        'x-csrf-token': cookie.parsed['csrf-token'],
        'sec-fetch-site': 'same-site',
        'sec-fetch-mode': 'cors',
        cookie: `gnar_containrId=${cookie.parsed.gnar_containerId}; grauth=${cookie.parsed.grauth}; csrf-token=${cookie.parsed['csrf-token']}`,
    };
    const response = await fetch__default['default']('https://auth.grammarly.com/v3/api/login', {
        follow: 0,
        compress: true,
        method: 'POST',
        body: JSON.stringify({
            email_login: { email: username, password, secureLogin: false },
        }),
        headers,
    });
    if (response.ok) {
        const cookies = response.headers.raw()['set-cookie'];
        try {
            const data = await response.json();
            if (process.env.NODE_ENV !== 'production')
                LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.info('Authentication successful:', data);
        }
        catch { }
        return {
            isAnonymous: false,
            token: toCookie({
                ...cookie.parsed,
                ...cookieToObject(cookies),
            }),
            container: cookie.parsed.gnar_containerId,
            username,
        };
    }
    try {
        const contents = await response.text();
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.error(`anonymous connection failed: ${response.status} - ${response.statusText}`, contents);
        const result = JSON.parse(contents);
        if (result.error === 'SHOW_CAPTCHA') {
            const error = new Error('Authentication requires captcha input.');
            // @ts-ignore
            error.code = result.error;
            throw error;
        }
    }
    catch {
        if (process.env.NODE_ENV !== 'production')
            LOGGER === null || LOGGER === void 0 ? void 0 : LOGGER.error(`anonymous connection failed: ${response.status} - ${response.statusText}`);
    }
    const error = new Error(response.statusText);
    // @ts-ignore
    error.code = result.error;
    throw error;
}

var name = "unofficial-grammarly-api";
var version = "0.0.0";

class SocketError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
    }
}

const RequestKind = {
    DEBUG_INFO: 'get_debug_info',
    FEEDBACK: 'feedback',
    OPTION: 'option',
    PING: 'ping',
    SET_CONTEXT: 'set_context',
    START: 'start',
    SUBMIT_OT: 'submit_ot',
    SUBMIT_OT_CHUNK: 'submit_ot_chunk',
    SYNONYMS: 'synonyms',
    TEXT_STATS: 'get_text_stats',
    TOGGLE_CHECKS: 'toggle_checks',
};

function isRequestType(request, kind) {
    return request.action === kind;
}

const ResponseKind = {
    ALERT: 'alert',
    ALERT_CHANGES: 'alert_changes',
    ASYNC_CHECK_FINISHED: 'async_check_finished',
    COMPLETE: 'complete',
    DEBUG_INFO: 'debug_info',
    EMOTIONS: 'emotions',
    ERROR: 'error',
    FEEDBACK: 'feedback',
    FINISHED: 'finished',
    HEATMAP: 'heatmap',
    OPTION: 'option',
    PING: 'pong',
    PLAGIARISM: 'plagiarism',
    REMOVE: 'remove',
    SET_CONTEXT: 'set_context',
    START: 'start',
    SUBMIT_OT: 'submit_ot',
    SUBMIT_OT_CHUNK: 'submit_ot_chunk',
    SYNONYMS: 'synonyms',
    TAKEAWAYS: 'takeaways',
    TEXT_INFO: 'text_info',
    TEXT_MAPS: 'text_maps',
    TEXT_STATS: 'text_stats',
    TOGGLE_CHECKS: 'toggle_checks',
};

function isResponseType(request, kind) {
    return request.action === kind;
}
function isEvent(message) {
    switch (message.action) {
        case ResponseKind.START:
        case ResponseKind.SUBMIT_OT:
        case ResponseKind.SUBMIT_OT_CHUNK:
        case ResponseKind.FEEDBACK:
        case ResponseKind.PING:
        case ResponseKind.OPTION:
        case ResponseKind.TEXT_STATS:
        case ResponseKind.DEBUG_INFO:
        case ResponseKind.SYNONYMS:
        case ResponseKind.SET_CONTEXT:
        case ResponseKind.TOGGLE_CHECKS:
            return false;
        default:
            return true;
    }
}
function isAckResponse(message) {
    return !isEvent(message);
}

// TODO: Remove dependency on "ws" for browser usage.
const UA$1 = `${name} v${version} (NodeJS v${process.version})`;
class SocketClient {
    constructor(id, _getToken, _onConnection = () => { }, _onMessage = () => { }, UA = '') {
        this.id = id;
        this._getToken = _getToken;
        this._onConnection = _onConnection;
        this._onMessage = _onMessage;
        this.UA = UA;
        this.LOGGER = process.env.NODE_ENV !== 'production' ? new DevLogger(SocketClient.name, this.id) : null;
        this._socket = null;
        this._canReconnect = true;
        this._statusCode = null;
        this._statusMessage = null;
        this._pendingResponses = 0;
        this._nextId = 0;
        this._queue = [];
        this._callbacks = new Map();
        this.status = 'closed';
        this.UA = `${this.UA} ${UA}`;
        this._connect();
    }
    _setStatus(value) {
        var _a;
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`WebSocket: Connection status changed: ${this.status} -> ${value}`);
        // @ts-expect-error 2540 - Internally writable
        this.status = value;
    }
    dispose() {
        var _a;
        (_a = this._socket) === null || _a === void 0 ? void 0 : _a.close(SocketErrorCode.GOING_AWAY);
    }
    async send(message, priority = false) {
        const request = { ...message, id: this._nextId };
        this._nextId += 1;
        return new Promise((resolve) => {
            this._callbacks.set(request.id, (response) => resolve(response));
            this._queueOrSend(request, priority);
        });
    }
    async forceReConnect() {
        var _a;
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace('[FORCE] Reconnect to CAPI');
        this._canReconnect = true;
        await this._connect();
    }
    async _connect() {
        var _a, _b, _c, _d, _e;
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace('Connect: Initiate CAPI connection');
        if (this.status === 'connecting') {
            if (process.env.NODE_ENV !== 'production')
                (_b = this.LOGGER) === null || _b === void 0 ? void 0 : _b.trace('Connect: Another request in progress');
            return;
        }
        if (this._socket) {
            if (process.env.NODE_ENV !== 'production')
                (_c = this.LOGGER) === null || _c === void 0 ? void 0 : _c.trace('Connect: Already connected');
            return;
        }
        if (!this._canReconnect) {
            if (process.env.NODE_ENV !== 'production')
                (_d = this.LOGGER) === null || _d === void 0 ? void 0 : _d.trace(`Connect: Aborting due to pre-existing error - ${this._statusCode}: ${this._statusMessage}`);
            throw new SocketError(this._statusCode, `Socket connection failed: ${this._statusMessage}`);
        }
        const cookies = await this._getToken();
        this._pendingResponses = 0;
        this._nextId = 0;
        this._queue = [];
        this._setStatus('connecting');
        this._statusCode = null;
        this._statusMessage = null;
        this._socket = new WebSocket__default['default']('wss://capi.grammarly.com/freews', {
            headers: { 'User-Agent': this.UA, Accept: 'application/json', Cookie: cookies },
        });
        if (process.env.NODE_ENV !== 'production')
            (_e = this.LOGGER) === null || _e === void 0 ? void 0 : _e.trace('Send Headers: ', { 'User-Agent': this.UA, Accept: 'application/json', Cookie: cookies });
        this._socket.onopen = () => {
            var _a;
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace('WebSocket: Connection established.');
            this._setStatus('connected');
            this._queue.length = 0;
            this._onConnection();
            this._flushQueue();
        };
        this._socket.onclose = (event) => {
            var _a;
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`WebSocket: Connection closed - ${event.code}: ${event.reason}`);
            this._socket = null;
            switch (event.code) {
                case SocketErrorCode.BAD_REQUEST:
                case SocketErrorCode.GOING_AWAY:
                case SocketErrorCode.UNAUTHORIZED:
                    this._canReconnect = false;
                    break;
                case SocketErrorCode.CLOSED_ABNORMALLY:
                case SocketErrorCode.SERVER_ERROR:
                case SocketErrorCode.SERVER_SHUTDOWN:
                    this._canReconnect = true;
                    break;
                default:
                    this._canReconnect = true;
                    break;
            }
            this._statusCode = event.code;
            this._statusMessage = event.reason;
            if (this.status !== 'errored') {
                this._setStatus('closed');
            }
        };
        this._socket.onmessage = (event) => {
            var _a, _b;
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`WebSocket: Message - ${event.type}`);
            try {
                const response = JSON.parse(event.data.toString());
                this._handleMessage(response);
            }
            catch (error) {
                if (process.env.NODE_ENV !== 'production')
                    (_b = this.LOGGER) === null || _b === void 0 ? void 0 : _b.error('WebSocket: Failed to parse response -', error);
            }
        };
        this._socket.onerror = (event) => {
            var _a;
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.error(`WebSocket: Error - ${event.type}: ${event.message}`, event.error);
            this._setStatus('errored');
        };
    }
    _queueOrSend(message, priority) {
        var _a;
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.debug(`WebSocket: Send(${message.id}): ${message.action}`);
        if (!this._socket) {
            this._connect();
            this._queueMessage(message);
        }
        else if (isRequestType(message, RequestKind.START)) {
            this._sendStartMessage(message);
        }
        else if (this.status === 'ready') {
            this._sendAnyMessage(message, priority);
        }
        else {
            this._queueMessage(message);
        }
    }
    /**
     * Ensure socket is in ready state.
     */
    _sendAnyMessage(message, priority) {
        if (this._pendingResponses <= 0 || priority) {
            this._sendToSocket(message);
        }
        else {
            this._queueMessage(message);
        }
    }
    _sendStartMessage(message) {
        if (this.status === 'connected') {
            this._sendToSocket(message);
        }
        else {
            this._queueMessage(message, true);
        }
    }
    _queueMessage(message, atStart = false) {
        var _a;
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`CAPI: Queue(${message.id}) — ${message.action}`);
        if (atStart)
            this._queue.unshift(message);
        else
            this._queue.push(message);
    }
    _sendToSocket(message) {
        var _a;
        if (!this._socket)
            throw new Error(`InternalError: sending before connection is established.`);
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.debug(`CAPI: Send(${message.id}) — ${message.action}`, message);
        this._socket.send(JSON.stringify(message));
        this._pendingResponses += 1;
    }
    _flushQueue() {
        var _a;
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`WebSocket: Flushing queue`);
        const message = this._queue.shift();
        if (message)
            this._sendToSocket(message);
    }
    _handleMessage(response) {
        var _a, _b;
        if (isResponseType(response, ResponseKind.START)) {
            if (this.status === 'connected') {
                this._setStatus('ready');
            }
        }
        if (isAckResponse(response)) {
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.debug(`CAPI: Ack(${response.id}) — ${response.action}`, response);
            this._pendingResponses -= 1;
            const callback = this._callbacks.get(response.id);
            try {
                callback(response);
            }
            catch { }
            this._callbacks.delete(response.id);
        }
        else {
            if (process.env.NODE_ENV !== 'production')
                (_b = this.LOGGER) === null || _b === void 0 ? void 0 : _b.debug(`CAPI: Recv() — ${response.action}`, response);
        }
        try {
            this._onMessage(response);
        }
        catch { }
        if (isAckResponse(response))
            this._flushQueue();
    }
}
const SocketErrorCode = {
    GOING_AWAY: 1001,
    CLOSED_ABNORMALLY: 1006,
    SERVER_ERROR: 1011,
    BAD_REQUEST: 4000,
    UNAUTHORIZED: 4001,
    SERVER_SHUTDOWN: 4002,
};

function noop() { }
class GrammarlyClient extends SocketClient {
    constructor(options) {
        var _a, _b;
        super(options.documentId, options.getToken, (_a = options.onConnection) !== null && _a !== void 0 ? _a : noop, (message) => {
            if (options.onMessage != null)
                options.onMessage(message);
            if (isEvent(message)) {
                this.handlers.forEach((fn) => fn(message));
                if (message.action === ResponseKind.ERROR && this.options.onError != null) {
                    const error = new Error(message.error);
                    Object.assign(error, message);
                    this.options.onError(error);
                }
            }
        }, `Client: ${options.clientName} (${options.clientType}) v${(_b = options.clientVersion) !== null && _b !== void 0 ? _b : '0.0.0'}`);
        this.options = options;
        this.handlers = new Set();
    }
    async reconnect() {
        return this.forceReConnect();
    }
    async sendWithErrorHandling(request, priority = false) {
        try {
            return await this.send(request, priority);
        }
        catch (error) {
            if (this.options.onError)
                this.options.onError(error);
            throw error;
        }
    }
    onEvent(kind, fn) {
        const handler = (event) => {
            if (isResponseType(event, kind)) {
                fn(event);
            }
        };
        this.handlers.add(handler);
        return () => this.handlers.delete(handler);
    }
    onAlert(fn) {
        return this.onEvent(ResponseKind.ALERT, fn);
    }
    onRemove(fn) {
        return this.onEvent(ResponseKind.REMOVE, fn);
    }
    onAlertsChanged(fn) {
        return this.onEvent(ResponseKind.ALERT_CHANGES, fn);
    }
    onAsyncCheckFinished(fn) {
        return this.onEvent(ResponseKind.ASYNC_CHECK_FINISHED, fn);
    }
    onComplete(fn) {
        return this.onEvent(ResponseKind.COMPLETE, fn);
    }
    onEmotion(fn) {
        return this.onEvent(ResponseKind.EMOTIONS, fn);
    }
    onFinished(fn) {
        return this.onEvent(ResponseKind.FINISHED, fn);
    }
    onHeatmap(fn) {
        return this.onEvent(ResponseKind.HEATMAP, fn);
    }
    onPlagiarism(fn) {
        return this.onEvent(ResponseKind.PLAGIARISM, fn);
    }
    onTakeaways(fn) {
        return this.onEvent(ResponseKind.TAKEAWAYS, fn);
    }
    onTextInfo(fn) {
        return this.onEvent(ResponseKind.TEXT_INFO, fn);
    }
    onTextMaps(fn) {
        return this.onEvent(ResponseKind.TEXT_MAPS, fn);
    }
    async ping() {
        return await this.send({ id: 0, action: RequestKind.PING });
    }
    async start(options) {
        var _a;
        return this.send({
            dialect: 'british',
            clientSupports: [
                'alerts_changes',
                'alerts_update',
                'completions',
                'consistency_check',
                'emogenie_check',
                'filler_words_check',
                'free_clarity_alerts',
                'free_inline_advanced_alerts',
                'full_sentence_rewrite_card',
                'key_takeaways',
                'mute_quoted_alerts',
                'plagiarism_alerts_update',
                'readability_check',
                'sentence_variety_check',
                'set_goals_link',
                'super_alerts',
                'text_info',
                'tone_cards',
                'user_mutes',
                'vox_check',
            ],
            ...options,
            id: 0,
            docid: this.id,
            client: this.options.clientName,
            clientSubtype: this.options.clientType,
            clientVersion: (_a = this.options.clientVersion) !== null && _a !== void 0 ? _a : '0.0.0',
            action: RequestKind.START,
        });
    }
    async submitOT(options) {
        return this.sendWithErrorHandling({ ...options, id: 0, action: RequestKind.SUBMIT_OT });
    }
    async sendFeedbackForAlert(message) {
        return this.sendWithErrorHandling({
            ...message,
            id: 0,
            action: RequestKind.FEEDBACK,
        });
    }
    async setOption(message) {
        return this.sendWithErrorHandling({ ...message, id: 0, action: RequestKind.OPTION });
    }
    async setContext(message) {
        return this.sendWithErrorHandling({ ...message, id: 0, action: RequestKind.SET_CONTEXT });
    }
    async toggleChecks(message) {
        return this.sendWithErrorHandling({ ...message, id: 0, action: RequestKind.TOGGLE_CHECKS });
    }
    async getTextStats(message) {
        return this.sendWithErrorHandling({ ...message, id: 0, action: RequestKind.TEXT_STATS }, true);
    }
    async getDebugInfo(message) {
        return this.sendWithErrorHandling({ ...message, id: 0, action: RequestKind.DEBUG_INFO }, true);
    }
    async getSynonyms(message) {
        return this.sendWithErrorHandling({ ...message, id: 0, action: RequestKind.SYNONYMS }, true);
    }
}

function getIdRevision(rev) {
    return rev;
}

async function createCheckClient(text, options) {
    return new Promise(async (resolve) => {
        var _a, _b;
        const client = new GrammarlyClient({
            documentId: Buffer.from(text).toString('hex').substr(0, 64),
            clientName: (_a = options === null || options === void 0 ? void 0 : options.clientName) !== null && _a !== void 0 ? _a : 'generic-check',
            clientType: 'general',
            clientVersion: (_b = options === null || options === void 0 ? void 0 : options.clientVersion) !== null && _b !== void 0 ? _b : version,
            getToken: async () => {
                const result = await ((options === null || options === void 0 ? void 0 : options.credentials) != null
                    ? authenticate(options.credentials.username, options.credentials.password)
                    : anonymous());
                return result.token;
            },
            onConnection: async () => {
                var _a, _b;
                await client.start({ dialect: (_b = (_a = options === null || options === void 0 ? void 0 : options.context) === null || _a === void 0 ? void 0 : _a.dialect) !== null && _b !== void 0 ? _b : 'american' });
                const { rev } = await client.submitOT({
                    rev: getIdRevision(0),
                    doc_len: 0,
                    deltas: [{ ops: [{ insert: text }] }],
                    chunked: false,
                });
                if ((options === null || options === void 0 ? void 0 : options.context) != null) {
                    await client.setContext({
                        rev,
                        documentContext: {
                            audience: 'knowledgeable',
                            dialect: 'american',
                            domain: 'general',
                            emotions: [],
                            goals: [],
                            style: 'neutral',
                            ...options.context,
                        },
                    });
                }
                resolve(client);
            },
        });
    });
}

async function checkGrammar(text, options) {
    const grammarly = await createCheckClient(text, options !== null && options !== void 0 ? options : {});
    const alerts = [];
    grammarly.onAlert((alert) => alerts.push(alert));
    return new Promise((resolve) => {
        grammarly.onFinished(() => {
            grammarly.dispose();
            resolve(alerts);
        });
    });
}

async function checkPlagiarism(text, options) {
    const alerts = [];
    const grammarly = await createCheckClient(text, options);
    await grammarly.toggleChecks({
        checks: {
            plagiarism: true,
        },
    });
    return new Promise((resolve) => {
        grammarly.onPlagiarism((alert) => alerts.push(alert));
        grammarly.onFinished(() => {
            grammarly.dispose();
            resolve(alerts);
        });
    });
}

function isIns(x) {
    return x.type === 'INS';
}
function isDel(x) {
    return x.type === 'DEL';
}
function ins(pos, text) {
    return {
        type: 'INS',
        pos: pos,
        text: text,
    };
}
function del(pos, length) {
    return {
        type: 'DEL',
        pos: pos,
        length: length,
    };
}
function getTransformOffsetFromTextChange(c) {
    if (isIns(c))
        return c.text.length;
    else if (isDel(c))
        return -c.length;
    else
        throw new Error(`Unexpected change: ${c}`);
}
function applyTextChanges(text, changes) {
    return changes.reduce((t, c) => {
        if (isIns(c)) {
            return t.slice(0, c.pos) + c.text + t.slice(c.pos);
        }
        else if (isDel(c)) {
            return t.slice(0, c.pos) + t.slice(c.pos + c.length);
        }
        else {
            throw new Error(`Unexpected change: ${c}`);
        }
    }, text);
}

class ChangeSet {
    constructor(callback) {
        this.callback = callback;
        this.ops = [];
        this.deltas = [];
        this.changes = [];
    }
    insertText(position, text) {
        if (position)
            this.ops.push({ retain: position });
        this.ops.push({ insert: text });
        this.changes.push(ins(position, text));
        return this;
    }
    deleteText(position, length) {
        if (position)
            this.ops.push({ retain: position });
        this.ops.push({ delete: length });
        this.changes.push(del(position, length));
        return this;
    }
    setText(text) {
        this.ops.push({ insert: text });
        return this;
    }
    commit() {
        if (this.ops.length) {
            this.deltas.push({ ops: this.ops });
            this.ops = [];
        }
        return this;
    }
    apply() {
        return this.commit().callback(this.deltas, this.changes);
    }
}

function rebaseTextRange(r, cs) {
    return cs.reduce((a, c) => {
        const o = getTransformOffsetFromTextChange(c);
        return {
            start: c.pos <= a.start ? a.start + o : a.start,
            end: c.pos < a.end ? a.end + o : a.end,
        };
    }, r);
}

exports.ChangeSet = ChangeSet;
exports.GrammarlyClient = GrammarlyClient;
exports.RequestKind = RequestKind;
exports.ResponseKind = ResponseKind;
exports.SocketClient = SocketClient;
exports.SocketError = SocketError;
exports.SocketErrorCode = SocketErrorCode;
exports.anonymous = anonymous;
exports.applyTextChanges = applyTextChanges;
exports.authenticate = authenticate;
exports.checkGrammar = checkGrammar;
exports.checkPlagiarism = checkPlagiarism;
exports.createCheckClient = createCheckClient;
exports.del = del;
exports.getIdRevision = getIdRevision;
exports.getTransformOffsetFromTextChange = getTransformOffsetFromTextChange;
exports.ins = ins;
exports.isAckResponse = isAckResponse;
exports.isDel = isDel;
exports.isEvent = isEvent;
exports.isIns = isIns;
exports.isRequestType = isRequestType;
exports.isResponseType = isResponseType;
exports.rebaseTextRange = rebaseTextRange;
//# sourceMappingURL=index.cjs.js.map
