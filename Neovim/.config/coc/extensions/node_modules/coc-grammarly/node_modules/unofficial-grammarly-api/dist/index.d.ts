interface AuthCookie {
    gnar_containerId: string;
    grauth: string;
    'csrf-token': string;
    funnelType: string;
    browser_info: string;
    redirect_location: string;
}
interface RawAuthCookie {
    raw: string;
    headers: string[];
    parsed: AuthCookie;
}
interface GrammarlyAuthContext {
    isAnonymous: boolean;
    token: string;
    container: string;
    username: string;
}
declare function anonymous(): Promise<GrammarlyAuthContext>;
declare function authenticate(username: string, password: string): Promise<GrammarlyAuthContext>;

declare type AlertFeedbackType = 'IGNORE' | 'ADD_TO_DICTIONARY' | 'LOOKED' | 'ACCEPTED' | 'CLOSED' | 'LIKE' | 'DISLIKE' | 'WRONG_SUGGESTION' | 'OFFENSIVE_CONTENT' | 'EXPANDED';

declare type Id<T> = number & {
    __type: T;
};

declare type IdAlert = Id<'Alert'>;

declare type AutocompleteFeedbackType = 'COMPLETION_SHOWN' | 'COMPLETION_IGNORED' | 'COMPLETION_ACCEPTED' | 'COMPLETION_REJECTED';

declare type AutoCorrectFeedbackType = 'AUTOCORRECT_ACCEPT' | 'AUTOCORRECT_DISMISS' | 'AUTOCORRECT_REPLACE';

declare type EmotionFeedbackType = 'EMOTION_LIKE' | 'EMOTION_DISLIKE';

declare type LensFeedbackType = 'LENS_CLOSE' | 'LENS_OPEN' | 'DISMISS_BY_LENS';

declare type MutedFeedbackType = 'MUTE' | 'UNMUTE';

declare type SystemFeedbackType = 'RECHECK_SHOWN';

declare type TakeawayFeedbackType = 'TAKEAWAY_LIKE' | 'TAKEAWAY_DISLIKE' | 'TAKEAWAY_LOOKED';

declare type FeedbackType = AlertFeedbackType | LensFeedbackType | EmotionFeedbackType | SystemFeedbackType | MutedFeedbackType | AutoCorrectFeedbackType | AutocompleteFeedbackType | TakeawayFeedbackType;

declare const RequestKind: {
    readonly DEBUG_INFO: "get_debug_info";
    readonly FEEDBACK: "feedback";
    readonly OPTION: "option";
    readonly PING: "ping";
    readonly SET_CONTEXT: "set_context";
    readonly START: "start";
    readonly SUBMIT_OT: "submit_ot";
    readonly SUBMIT_OT_CHUNK: "submit_ot_chunk";
    readonly SYNONYMS: "synonyms";
    readonly TEXT_STATS: "get_text_stats";
    readonly TOGGLE_CHECKS: "toggle_checks";
};
declare type RequestKindType = typeof RequestKind[keyof typeof RequestKind];

interface BaseRequest {
    id: number;
    action: RequestKindType;
}

interface BaseFeedbackRequest extends BaseRequest {
    type: FeedbackType;
}

interface AlertFeedbackRequest extends BaseFeedbackRequest {
    type: AlertFeedbackType;
    alertId: IdAlert;
    text?: string;
}

interface DebugInfoRequest extends BaseRequest {
    action: typeof RequestKind.DEBUG_INFO;
}

interface EmotionFeedbackRequest extends BaseFeedbackRequest {
    type: EmotionFeedbackType;
    emotion: string;
}

interface LensFeedbackRequest extends BaseFeedbackRequest {
    type: LensFeedbackType;
    lens: string;
}

declare type UserMutedScopeType = 'GLOBAL' | 'SESSION' | 'DOCUMENT';

interface MutedFeedbackRequest extends BaseFeedbackRequest {
    type: MutedFeedbackType;
    userMuteScope: UserMutedScopeType;
    userMuteCategories: string[];
}

declare type OptionType = 'gnar_containerId';

interface OptionRequest extends BaseRequest {
    action: typeof RequestKind.OPTION;
    name: OptionType;
    value: string;
}

interface PingRequest extends BaseRequest {
    action: typeof RequestKind.PING;
}

declare type DialectType = 'american' | 'australian' | 'british' | 'canadian';

declare type DocumentAudienceType = 'general' | 'knowledgeable' | 'expert';

declare type DocumentDomainType = 'academic' | 'business' | 'general' | 'technical' | 'casual' | 'creative';

declare type DocumentGoalType = 'inform' | 'describe' | 'convince' | 'tellStory';

declare type WritingEmotionType = 'neutral' | 'confident' | 'joyful' | 'optimistic' | 'friendly' | 'urgent' | 'analytical' | 'respectful';

declare type WritingStyleType = 'informal' | 'neutral' | 'formal';

interface DocumentContext {
    dialect: DialectType;
    domain: DocumentDomainType;
    goals: DocumentGoalType[];
    audience?: DocumentAudienceType;
    style?: WritingStyleType;
    emotions: WritingEmotionType[];
}

declare type IdRevision = Id<'Revision'>;
declare function getIdRevision(rev: number): IdRevision;

interface SetContextRequest extends BaseRequest {
    action: typeof RequestKind.SET_CONTEXT;
    rev: IdRevision;
    documentContext: DocumentContext;
}

declare type FeatureType = 'alerts_changes' | 'alerts_update' | 'alternative_deletes_card' | 'attention_heatmap' | 'completions' | 'consistency_check' | 'demo_text_free_premium_alerts' | 'emogenie_check' | 'filler_words_check' | 'free_clarity_alerts' | 'free_inline_advanced_alerts' | 'full_sentence_rewrite_card' | 'key_takeaways' | 'mute_quoted_alerts' | 'plagiarism_alerts_update' | 'readability_check' | 'sentence_variety_check' | 'set_goals_link' | 'super_alerts' | 'text_info' | 'tone_cards' | 'turn_to_list_card' | 'user_mutes' | 'vox_check';

interface StartRequest extends BaseRequest {
    action: typeof RequestKind.START;
    client: string;
    clientSubtype: string;
    clientVersion: string;
    dialect: DialectType;
    docid: string;
    documentContext?: DocumentContext;
    clientSupports?: FeatureType[];
}

declare type OpDelete = {
    delete: number;
};

declare type OpInsert = {
    insert: string;
};

declare type OpRetain = {
    retain: number;
};

declare type Op = OpRetain | OpInsert | OpDelete;

interface Delta {
    ops: Op[];
}

interface SubmitOTChunkRequest extends BaseRequest {
    action: typeof RequestKind.SUBMIT_OT_CHUNK;
    rev: IdRevision;
    doc_len: number;
    deltas: [Delta];
    chunked: false;
}

interface SubmitOTRequest extends BaseRequest {
    action: typeof RequestKind.SUBMIT_OT;
    rev: IdRevision;
    doc_len: number;
    deltas: Delta[];
    chunked: false;
}

interface SynonymsRequest extends BaseRequest {
    action: typeof RequestKind.SYNONYMS;
    begin: number;
    token: string;
}

interface SystemFeedbackRequest extends BaseFeedbackRequest {
    type: SystemFeedbackType;
}

interface TextStatsRequest extends BaseRequest {
    action: typeof RequestKind.TEXT_STATS;
}

declare type AsyncChecksTypes = 'plagiarism';

interface ToggleChecksRequest extends BaseRequest {
    action: typeof RequestKind.TOGGLE_CHECKS;
    checks: Record<AsyncChecksTypes, boolean>;
}

declare type FeedbackRequest = AlertFeedbackRequest | EmotionFeedbackRequest | LensFeedbackRequest | MutedFeedbackRequest | SystemFeedbackRequest;
declare type Request = DebugInfoRequest | FeedbackRequest | OptionRequest | PingRequest | SetContextRequest | StartRequest | SubmitOTRequest | SubmitOTChunkRequest | SynonymsRequest | TextStatsRequest | ToggleChecksRequest;
interface RequestTypeToRequestMapping {
    [RequestKind.DEBUG_INFO]: DebugInfoRequest;
    [RequestKind.FEEDBACK]: FeedbackRequest;
    [RequestKind.OPTION]: OptionRequest;
    [RequestKind.PING]: PingRequest;
    [RequestKind.SET_CONTEXT]: SetContextRequest;
    [RequestKind.START]: StartRequest;
    [RequestKind.SUBMIT_OT]: SubmitOTRequest;
    [RequestKind.SUBMIT_OT_CHUNK]: SubmitOTChunkRequest;
    [RequestKind.SYNONYMS]: SynonymsRequest;
    [RequestKind.TEXT_STATS]: TextStatsRequest;
    [RequestKind.TOGGLE_CHECKS]: ToggleChecksRequest;
}
declare function isRequestType<K extends keyof RequestTypeToRequestMapping>(request: any, kind: K): request is RequestTypeToRequestMapping[K];

declare type AlertImpactType = 'critical' | 'advanced';

declare type AlertMutedByType = 'MUTED_BY_USER' | 'NOT_ELIGIBLE_FOR_INLINE' | 'NOT_MUTED';

declare type AlertViewType = 'all' | 'priority';

declare type PredictionType = 'emogenie' | 'clarity';

interface AlertCardLayout {
    category: string;
    group: string;
    groupDescription: string;
    rank: number;
    outcome: string;
    outcomeDescription: string;
    prediction?: PredictionType;
    userMuteCategory?: string;
    userMuteCategoryDescription?: string;
}

interface EmogenieExtraProperties {
    tone: string;
    emoji: string;
    full_sentence_rewrite: string;
}

interface FluencyExtraProperties {
    fluency_message: string;
}

interface PlagiarismExtraProperties {
    source: 'WEB_PAGE' | 'PUBLICATION';
    percent: string;
    title: string;
    authors: string;
    reference_apa: string;
    reference_chicago: string;
    reference_mla: string;
}

interface VoxExtraProperties {
    voxCompanyName: string;
    voxLogoUrl: string;
}

declare type AlertExtraProperties = Partial<{
    add_to_dict: string;
    did_you_mean: string;
    show_title: string;
    enhancement: string;
    url: string;
    sentence: string;
    priority: string;
    progress: number;
} & PlagiarismExtraProperties & VoxExtraProperties & FluencyExtraProperties & EmogenieExtraProperties>;

interface Range {
    s: number;
    e: number;
    type?: 'main' | 'focus';
}

interface Transform {
    highlights: Range[];
    context: Range;
    alternatives?: Delta;
}

declare const ResponseKind: {
    readonly ALERT: "alert";
    readonly ALERT_CHANGES: "alert_changes";
    readonly ASYNC_CHECK_FINISHED: "async_check_finished";
    readonly COMPLETE: "complete";
    readonly DEBUG_INFO: "debug_info";
    readonly EMOTIONS: "emotions";
    readonly ERROR: "error";
    readonly FEEDBACK: "feedback";
    readonly FINISHED: "finished";
    readonly HEATMAP: "heatmap";
    readonly OPTION: "option";
    readonly PING: "pong";
    readonly PLAGIARISM: "plagiarism";
    readonly REMOVE: "remove";
    readonly SET_CONTEXT: "set_context";
    readonly START: "start";
    readonly SUBMIT_OT: "submit_ot";
    readonly SUBMIT_OT_CHUNK: "submit_ot_chunk";
    readonly SYNONYMS: "synonyms";
    readonly TAKEAWAYS: "takeaways";
    readonly TEXT_INFO: "text_info";
    readonly TEXT_MAPS: "text_maps";
    readonly TEXT_STATS: "text_stats";
    readonly TOGGLE_CHECKS: "toggle_checks";
};
declare type ResponseKindType = typeof ResponseKind[keyof typeof ResponseKind];

interface BaseResponse {
    action: ResponseKindType;
}

interface AlertEvent extends BaseResponse {
    id: IdAlert;
    action: typeof ResponseKind.ALERT;
    rev: IdRevision;
    begin: number;
    end: number;
    highlightBegin: number;
    highlightEnd: number;
    text: string;
    pname: string;
    point: string;
    highlightText: string;
    category: string;
    categoryHuman: string;
    group: string;
    title: string;
    details: string;
    examples: string;
    explanation: string;
    transforms: string[];
    replacements: string[];
    free: boolean;
    extra_properties: AlertExtraProperties;
    hidden: boolean;
    impact: AlertImpactType;
    cardLayout: AlertCardLayout;
    sentence_no: number;
    todo: string;
    minicardTitle: string;
    cost?: number;
    updatable?: boolean;
    transformJson?: Transform;
    labels?: string[];
    subalerts?: Array<{
        transformJson: Transform;
        highlightText: string;
        label: string;
    }>;
    muted?: AlertMutedByType;
    view?: AlertViewType;
}

interface AlertsChangedEvent extends BaseResponse {
    action: typeof ResponseKind.ALERT_CHANGES;
    extra_properties?: AlertExtraProperties;
    rev: IdRevision;
    transformJson?: Transform;
    muted?: AlertMutedByType;
}

interface OutcomeScores {
    Clarity: number;
    Correctness: number;
    Engagement: number;
    Tone: number;
    'Style guide': number;
    GeneralScore: number;
}

interface AsyncCheckFinishedEvent extends BaseResponse {
    action: typeof ResponseKind.ASYNC_CHECK_FINISHED;
    rev: IdRevision;
    check: 0;
    outcomeScores: OutcomeScores;
}

interface CompleteEvent extends BaseResponse {
    action: typeof ResponseKind.COMPLETE;
    completions: Array<{
        text: string;
        patternName: string;
        prefixBegin: number;
        prefixEnd: number;
        textBegin: number;
        textEnd: number;
        confidence: number;
        confidenceCurve: Readonly<Record<number, number>>;
    }>;
    threshold: number;
    rev: IdRevision;
}

interface Emotion {
    emoji: string;
    name: string;
    confidence: number;
}

interface EmotionsEvent extends BaseResponse {
    action: typeof ResponseKind.EMOTIONS;
    emotions: Emotion[];
}

declare type ErrorCodeType = 'not_authorized' | 'session_not_initialized' | 'bad_request' | 'backend_error' | 'auth_error' | 'runtime_error' | 'illegal_dict_word' | 'timeout' | 'cannot_find_synonym' | 'cannot_get_text_stats';

declare type ErrorSeverityType = 'INFO' | 'WARN' | 'ERROR';

interface ErrorEvent extends BaseResponse {
    action: typeof ResponseKind.ERROR;
    error: ErrorCodeType;
    severity: ErrorSeverityType;
}

interface FinishedEvent extends BaseResponse {
    action: typeof ResponseKind.FINISHED;
    rev: IdRevision;
    score: number;
    dialect: DialectType;
    outcomeScores?: Partial<OutcomeScores>;
    generalScore?: number;
    removed?: IdAlert[];
}

declare type IdHeatmap = Id<'Heatmap'>;

interface HeatmapRange {
    id: IdHeatmap;
    begin: number;
    end: number;
    text: string;
    intensities: [number, number];
}

interface HeatmapEvent extends BaseResponse {
    action: typeof ResponseKind.HEATMAP;
    add: HeatmapRange[];
    update: HeatmapRange[];
    remove: IdHeatmap[];
    rev: IdRevision;
    originalRev: IdRevision;
    version: number;
}

interface PlagiarismEvent extends BaseResponse {
    action: typeof ResponseKind.PLAGIARISM;
}

interface RemoveEvent extends BaseResponse {
    id: IdAlert;
    action: typeof ResponseKind.REMOVE;
    hint?: 'NOT_FIXED';
    mergedIn?: IdAlert;
}

declare type IdTakeaway = Id<'Takeaway'>;

declare type Takeaway = any;
interface TakeawaysEvent extends BaseResponse {
    action: typeof ResponseKind.TAKEAWAYS;
    add: Takeaway[];
    update: Takeaway[];
    remove: IdTakeaway[];
    rev: IdRevision;
}

interface TextInfoEvent extends BaseResponse {
    action: typeof ResponseKind.TEXT_INFO;
    wordsCount: number;
    charsCount: number;
    readabilityScore: number;
    messages?: {
        assistantHeader: string;
    };
}

interface TextMapsEvent extends BaseResponse {
    action: typeof ResponseKind.TEXT_MAPS;
    score: number;
    generalScore: number;
}

interface BaseAckResponse extends BaseResponse {
    id: number;
}

interface BaseFeedbackAckResponse extends BaseAckResponse {
    type: FeedbackType;
    scores?: OutcomeScores;
}

interface AlertFeedbackResponse extends BaseFeedbackAckResponse {
    type: AlertFeedbackType;
}

interface DebugInfoResponse extends BaseAckResponse {
    action: typeof ResponseKind['DEBUG_INFO'];
    rev: IdRevision;
    sid: number;
    text: string;
}

interface EmotionFeedbackResponse extends BaseFeedbackAckResponse {
    type: EmotionFeedbackType;
}

interface LensFeedbackResponse extends BaseFeedbackAckResponse {
    type: LensFeedbackType;
}

interface MutedFeedbackResponse extends BaseFeedbackAckResponse {
    type: MutedFeedbackType;
}

interface OptionResponse extends BaseAckResponse {
    action: typeof ResponseKind.OPTION;
}

interface PingResponse extends BaseAckResponse {
    action: typeof ResponseKind.PING;
}

interface SetContextResponse extends BaseAckResponse {
    action: typeof ResponseKind.SET_CONTEXT;
    rev: IdRevision;
}

interface StartResponse extends BaseAckResponse {
    action: typeof ResponseKind.START;
    sid: number;
}

interface SubmitOTChunkResponse extends BaseAckResponse {
    action: typeof ResponseKind.SUBMIT_OT_CHUNK;
    rev: IdRevision;
}

interface SubmitOTResponse extends BaseAckResponse {
    action: typeof ResponseKind.SUBMIT_OT;
    rev: IdRevision;
}

interface Synonym {
    base: string;
    derived: string;
}

interface SynonymsGroup {
    synonyms: Synonym[];
    meaning?: string;
}

interface SynonymsResponse extends BaseAckResponse {
    action: typeof ResponseKind.SYNONYMS;
    token: string;
    synonyms: {
        pos: number;
        meanings: SynonymsGroup[];
    };
}

interface SystemFeedbackResponse extends BaseFeedbackAckResponse {
    type: SystemFeedbackType;
}

interface DocumentStatistics {
    words: number;
    chars: number;
    sentences: number;
    uniqueWords: number;
    uniqueWordsIndex: number;
    rareWords: number;
    rareWordsIndex: number;
    wordLength: number;
    wordLengthIndex: number;
    sentenceLength: number;
    sentenceLengthIndex: number;
    readabilityScore: number;
    readabilityDescription: string;
}

interface TextStatsResponse extends BaseAckResponse, DocumentStatistics {
    action: typeof ResponseKind.TEXT_STATS;
}

interface ToggleChecksResponse extends BaseAckResponse {
    action: typeof ResponseKind.TOGGLE_CHECKS;
}

declare type Event = AlertEvent | AlertsChangedEvent | AsyncCheckFinishedEvent | CompleteEvent | EmotionsEvent | ErrorEvent | FinishedEvent | HeatmapEvent | PlagiarismEvent | RemoveEvent | TakeawaysEvent | TextInfoEvent | TextMapsEvent;
declare type FeedbackResponse = AlertFeedbackResponse | EmotionFeedbackResponse | LensFeedbackResponse | MutedFeedbackResponse | SystemFeedbackResponse;
declare type Response = AlertEvent | AlertsChangedEvent | AsyncCheckFinishedEvent | CompleteEvent | DebugInfoResponse | EmotionsEvent | ErrorEvent | FeedbackResponse | FinishedEvent | HeatmapEvent | OptionResponse | PlagiarismEvent | PingResponse | RemoveEvent | SetContextResponse | StartResponse | SubmitOTResponse | SubmitOTChunkResponse | SynonymsResponse | TakeawaysEvent | TextInfoEvent | TextMapsEvent | TextStatsResponse | ToggleChecksResponse;
interface ResponseTypeToResponseMapping {
    [ResponseKind.ALERT]: AlertEvent;
    [ResponseKind.ALERT_CHANGES]: AlertsChangedEvent;
    [ResponseKind.ASYNC_CHECK_FINISHED]: AsyncCheckFinishedEvent;
    [ResponseKind.COMPLETE]: CompleteEvent;
    [ResponseKind.DEBUG_INFO]: DebugInfoResponse;
    [ResponseKind.EMOTIONS]: EmotionsEvent;
    [ResponseKind.ERROR]: ErrorEvent;
    [ResponseKind.FEEDBACK]: FeedbackResponse;
    [ResponseKind.FINISHED]: FinishedEvent;
    [ResponseKind.HEATMAP]: HeatmapEvent;
    [ResponseKind.OPTION]: OptionResponse;
    [ResponseKind.PING]: PlagiarismEvent;
    [ResponseKind.PLAGIARISM]: PingResponse;
    [ResponseKind.REMOVE]: RemoveEvent;
    [ResponseKind.SET_CONTEXT]: SetContextResponse;
    [ResponseKind.START]: StartResponse;
    [ResponseKind.SUBMIT_OT]: SubmitOTResponse;
    [ResponseKind.SUBMIT_OT_CHUNK]: SubmitOTChunkResponse;
    [ResponseKind.SYNONYMS]: SynonymsResponse;
    [ResponseKind.TAKEAWAYS]: TakeawaysEvent;
    [ResponseKind.TEXT_INFO]: TextInfoEvent;
    [ResponseKind.TEXT_MAPS]: TextMapsEvent;
    [ResponseKind.TEXT_STATS]: TextStatsResponse;
    [ResponseKind.TOGGLE_CHECKS]: ToggleChecksResponse;
}
interface RequestTypeToResponseMapping {
    [RequestKind.DEBUG_INFO]: DebugInfoResponse;
    [RequestKind.FEEDBACK]: FeedbackResponse;
    [RequestKind.OPTION]: OptionResponse;
    [RequestKind.PING]: PingResponse;
    [RequestKind.SET_CONTEXT]: SetContextResponse;
    [RequestKind.START]: StartResponse;
    [RequestKind.SUBMIT_OT]: SubmitOTResponse;
    [RequestKind.SUBMIT_OT_CHUNK]: SubmitOTChunkResponse;
    [RequestKind.SYNONYMS]: SynonymsResponse;
    [RequestKind.TEXT_STATS]: TextStatsResponse;
    [RequestKind.TOGGLE_CHECKS]: ToggleChecksResponse;
}
declare type ResponseOf<T extends Request> = RequestTypeToResponseMapping[T['action']];
declare function isResponseType<K extends keyof ResponseTypeToResponseMapping>(request: any, kind: K): request is ResponseTypeToResponseMapping[K];
declare function isEvent(message: Response): message is Event;
declare function isAckResponse(message: Response): message is Exclude<Response, Event>;

declare class SocketClient {
    readonly id: string;
    private readonly _getToken;
    private readonly _onConnection;
    private readonly _onMessage;
    private UA;
    private LOGGER;
    private _socket;
    private _canReconnect;
    private _statusCode;
    private _statusMessage;
    private _pendingResponses;
    private _nextId;
    private _queue;
    private _callbacks;
    readonly status: SocketConnectionStatus;
    private _setStatus;
    constructor(id: string, _getToken: () => Promise<string> | string, _onConnection?: () => void, _onMessage?: (message: Response) => void, UA?: string);
    dispose(): void;
    protected send<T extends Request>(message: T, priority?: boolean): Promise<ResponseOf<T>>;
    protected forceReConnect(): Promise<void>;
    private _connect;
    private _queueOrSend;
    /**
     * Ensure socket is in ready state.
     */
    private _sendAnyMessage;
    private _sendStartMessage;
    private _queueMessage;
    private _sendToSocket;
    private _flushQueue;
    private _handleMessage;
}
declare const SocketErrorCode: {
    GOING_AWAY: number;
    CLOSED_ABNORMALLY: number;
    SERVER_ERROR: number;
    BAD_REQUEST: number;
    UNAUTHORIZED: number;
    SERVER_SHUTDOWN: number;
};
declare type SocketErrorCodeType = typeof SocketErrorCode[keyof typeof SocketErrorCode];
declare type SocketConnectionStatus = 'connecting' | 'connected' | 'ready' | 'errored' | 'closed';

declare type Payload<T extends Request> = Omit<T, 'id' | 'action'>;
declare type EventHandler<T extends Event> = (event: T) => void;
declare type StopEventHandler = () => void;
interface GrammarlyClientOptions {
    documentId: string;
    clientName: string;
    clientType: 'general';
    clientVersion?: string;
    getToken: () => Promise<string> | string;
    onConnection?: () => void;
    onMessage?: (message: Response) => void;
    onError?: (error: Error) => void;
}
declare class GrammarlyClient extends SocketClient {
    private readonly options;
    private handlers;
    constructor(options: GrammarlyClientOptions);
    reconnect(): Promise<void>;
    private sendWithErrorHandling;
    onEvent<T extends Event>(kind: T['action'], fn: EventHandler<T>): StopEventHandler;
    onAlert(fn: EventHandler<AlertEvent>): StopEventHandler;
    onRemove(fn: EventHandler<RemoveEvent>): StopEventHandler;
    onAlertsChanged(fn: EventHandler<AlertsChangedEvent>): StopEventHandler;
    onAsyncCheckFinished(fn: EventHandler<AsyncCheckFinishedEvent>): StopEventHandler;
    onComplete(fn: EventHandler<CompleteEvent>): StopEventHandler;
    onEmotion(fn: EventHandler<EmotionsEvent>): StopEventHandler;
    onFinished(fn: EventHandler<FinishedEvent>): StopEventHandler;
    onHeatmap(fn: EventHandler<HeatmapEvent>): StopEventHandler;
    onPlagiarism(fn: EventHandler<PlagiarismEvent>): StopEventHandler;
    onTakeaways(fn: EventHandler<TakeawaysEvent>): StopEventHandler;
    onTextInfo(fn: EventHandler<TextInfoEvent>): StopEventHandler;
    onTextMaps(fn: EventHandler<TextMapsEvent>): StopEventHandler;
    ping(): Promise<PingResponse>;
    start(options: Partial<Pick<StartRequest, 'dialect' | 'clientSupports' | 'documentContext'>>): Promise<StartResponse>;
    submitOT(options: Payload<SubmitOTRequest>): Promise<SubmitOTResponse>;
    sendFeedbackForAlert(message: Payload<AlertFeedbackRequest>): Promise<AlertFeedbackResponse>;
    setOption(message: Payload<OptionRequest>): Promise<OptionResponse>;
    setContext(message: Payload<SetContextRequest>): Promise<SetContextResponse>;
    toggleChecks(message: Payload<ToggleChecksRequest>): Promise<ToggleChecksResponse>;
    getTextStats(message: Payload<TextStatsRequest>): Promise<TextStatsResponse>;
    getDebugInfo(message: Payload<DebugInfoRequest>): Promise<DebugInfoResponse>;
    getSynonyms(message: Payload<SynonymsRequest>): Promise<SynonymsResponse>;
}

interface CheckOptions {
    clientName?: string;
    clientVersion?: string;
    credentials: {
        username: string;
        password: string;
    };
    context?: Partial<DocumentContext>;
}
declare function createCheckClient(text: string, options: Partial<CheckOptions>): Promise<GrammarlyClient>;

declare function checkGrammar(text: string, options?: CheckOptions): Promise<AlertEvent[]>;

declare function checkPlagiarism(text: string, options: CheckOptions): Promise<PlagiarismEvent[]>;

declare type SuggestionRejectionReasonType = 'NOT_RELEVANT' | 'WRONG_TONE' | 'INCORRECT' | 'WRONG_GRAMMAR' | 'OFFENSIVE' | 'OTHER';

declare type SynonymFeedbackType = 'SYNONYM_ACCEPTED';

declare type WritingToneType = 'mild';

interface OutcomeScoresWithPlagiarism extends OutcomeScores {
    Originality: number;
}

interface TextChangeDelete {
    type: 'DEL';
    pos: number;
    length: number;
}

interface TextChangeInsert {
    type: 'INS';
    pos: number;
    text: string;
}

declare type TextChange = TextChangeInsert | TextChangeDelete;
declare function isIns(x: TextChange): x is TextChangeInsert;
declare function isDel(x: TextChange): x is TextChangeDelete;
declare function ins(pos: number, text: string): TextChangeInsert;
declare function del(pos: number, length: number): TextChangeDelete;
declare function getTransformOffsetFromTextChange(c: TextChange): number;
declare function applyTextChanges(text: string, changes: TextChange[]): string;

declare class ChangeSet {
    private callback;
    private ops;
    private deltas;
    private changes;
    constructor(callback: (deltas: Delta[], changes: TextChange[]) => Promise<void>);
    insertText(position: number, text: string): this;
    deleteText(position: number, length: number): this;
    setText(text: string): this;
    commit(): this;
    apply(): Promise<void>;
}

interface TextRange {
    start: number;
    end: number;
}
declare function rebaseTextRange(r: TextRange, cs: TextChange[]): TextRange;

declare class SocketError extends Error {
    readonly code: number;
    constructor(code: number, message: string);
}

export { AlertCardLayout, AlertEvent, AlertExtraProperties, AlertFeedbackRequest, AlertFeedbackResponse, AlertFeedbackType, AlertImpactType, AlertViewType, AlertsChangedEvent, AsyncCheckFinishedEvent, AsyncChecksTypes, AuthCookie, AutoCorrectFeedbackType, AutocompleteFeedbackType, ChangeSet, CheckOptions, CompleteEvent, DebugInfoRequest, DebugInfoResponse, Delta, DialectType, DocumentAudienceType, DocumentContext, DocumentDomainType, DocumentGoalType, DocumentStatistics, Emotion, EmotionFeedbackRequest, EmotionFeedbackResponse, EmotionFeedbackType, EmotionsEvent, ErrorCodeType, ErrorEvent, ErrorSeverityType, Event, FeatureType, FeedbackRequest, FeedbackResponse, FeedbackType, FinishedEvent, FluencyExtraProperties, GrammarlyAuthContext, GrammarlyClient, GrammarlyClientOptions, HeatmapEvent, HeatmapRange, IdAlert, IdHeatmap, IdRevision, IdTakeaway, LensFeedbackRequest, LensFeedbackResponse, LensFeedbackType, MutedFeedbackRequest, MutedFeedbackResponse, MutedFeedbackType, Op, OpDelete, OpInsert, OpRetain, OptionRequest, OptionResponse, OptionType, OutcomeScores, OutcomeScoresWithPlagiarism, PingRequest, PingResponse, PlagiarismEvent, PlagiarismExtraProperties, PredictionType, Range, RawAuthCookie, RemoveEvent, Request, RequestKind, RequestKindType, RequestTypeToRequestMapping, RequestTypeToResponseMapping, Response, ResponseKind, ResponseKindType, ResponseOf, ResponseTypeToResponseMapping, SetContextRequest, SetContextResponse, SocketClient, SocketConnectionStatus, SocketError, SocketErrorCode, SocketErrorCodeType, StartRequest, StartResponse, SubmitOTChunkRequest, SubmitOTChunkResponse, SubmitOTRequest, SubmitOTResponse, SuggestionRejectionReasonType, Synonym, SynonymFeedbackType, SynonymsGroup, SynonymsRequest, SynonymsResponse, SystemFeedbackRequest, SystemFeedbackResponse, SystemFeedbackType, TakeawayFeedbackType, TakeawaysEvent, TextChange, TextChangeDelete, TextChangeInsert, TextInfoEvent, TextMapsEvent, TextRange, TextStatsRequest, TextStatsResponse, ToggleChecksRequest, ToggleChecksResponse, Transform, UserMutedScopeType, VoxExtraProperties, WritingEmotionType, WritingStyleType, WritingToneType, anonymous, applyTextChanges, authenticate, checkGrammar, checkPlagiarism, createCheckClient, del, getIdRevision, getTransformOffsetFromTextChange, ins, isAckResponse, isDel, isEvent, isIns, isRequestType, isResponseType, rebaseTextRange };
