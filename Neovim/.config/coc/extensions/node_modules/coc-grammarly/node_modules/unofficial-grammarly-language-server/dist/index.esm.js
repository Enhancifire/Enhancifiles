import 'reflect-metadata';
import { injectable, inject, Container } from 'inversify';
import { DiagnosticSeverity, Disposable, TextDocuments, TextDocumentSyncKind, CodeActionKind, DiagnosticTag, createConnection, ProposedFeatures } from 'vscode-languageserver';
import minimatch from 'minimatch';
import { TextDocument } from 'vscode-languageserver-textdocument';
import remark from 'remark';
import IntervalTree from '@flatten-js/interval-tree';
import { GrammarlyClient, SocketError, ResponseKind, ChangeSet, SocketErrorCode, anonymous, authenticate, rebaseTextRange } from 'unofficial-grammarly-api';
import { ref, stop, effect, isRef } from '@vue/reactivity';
import { EventEmitter } from 'events';
import { inspect } from 'util';

const CLIENT = Symbol('ClientCapabilities');
const SERVER = Symbol('ServerCapabilities');
const CONNECTION = Symbol('Connection');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

const DEFAULT = {
    /** Extension Config */
    autoActivate: true,
    ignore: [],
    severity: {
        Determiners: DiagnosticSeverity.Error,
        Misspelled: DiagnosticSeverity.Error,
        Unknown: DiagnosticSeverity.Error,
        ClosingPunct: DiagnosticSeverity.Error,
        Nouns: DiagnosticSeverity.Error,
        OddWords: DiagnosticSeverity.Warning,
        CompPunct: DiagnosticSeverity.Warning,
        Clarity: DiagnosticSeverity.Warning,
        Dialects: DiagnosticSeverity.Warning,
        WordChoice: DiagnosticSeverity.Information,
        Readability: DiagnosticSeverity.Information,
        PassiveVoice: DiagnosticSeverity.Hint,
        _default: DiagnosticSeverity.Hint,
    },
    userWords: [],
    diagnostics: {
        '[markdown]': {
            ignore: ['code'],
        },
        '[mdx]': {
            ignore: ['code'],
        },
    },
    /** Grammarly Config */
    audience: 'knowledgeable',
    dialect: 'american',
    domain: 'general',
    emotions: [],
    goals: [],
    style: 'neutral',
    /** Grammarly Document Config */
    overrides: [],
    /** Internal */
    debug: false,
    showExplanation: true,
    showExamples: false,
    hideUnavailablePremiumAlerts: false,
};

function toArray(item) {
    if (!item)
        return [];
    else if (Array.isArray(item))
        return item;
    else
        return [item];
}

let ConfigurationService = class ConfigurationService {
    constructor(connection) {
        this.connection = connection;
        this.default = DEFAULT;
        this.user = this.default;
        this.perDocumentSettings = new Map();
        this.wip = new Map();
    }
    get settings() {
        return this.user;
    }
    register() {
        this.connection.onDidChangeConfiguration(({ settings }) => {
            console.log(settings);
            if ('grammarly' in settings) {
                this.user = {
                    ...this.default,
                    ...settings.grammarly,
                };
                this.perDocumentSettings.clear();
                this.wip.clear();
            }
        });
        setTimeout(() => {
            this.connection.workspace.getConfiguration('grammarly').then((settings) => {
                this.user = {
                    ...this.default,
                    ...settings,
                };
            });
        }, 0);
        return Disposable.create(() => {
            this.wip.clear();
            this.perDocumentSettings.clear();
        });
    }
    async getAlertSeverity(uri) {
        const config = await this.connection.workspace.getConfiguration({
            scopeUri: uri,
            section: 'grammarly',
        });
        return {
            ...this.default.severity,
            ...config === null || config === void 0 ? void 0 : config.severity,
        };
    }
    async getIgnoredTags(uri, languageId) {
        var _a;
        const config = await this.connection.workspace.getConfiguration({
            scopeUri: uri,
            section: 'grammarly',
        });
        return ((_a = config.diagnostics[`[${languageId}]`]) === null || _a === void 0 ? void 0 : _a.ignore) || [];
    }
    getDocumentSettings(uri, fresh = false) {
        if (this.perDocumentSettings.has(uri) && fresh === false) {
            return this.perDocumentSettings.get(uri);
        }
        if (this.wip.has(uri)) {
            return this.wip.get(uri);
        }
        const get = async () => {
            const config = {
                ...this.user,
                ...(await this.connection.workspace.getConfiguration({
                    scopeUri: uri,
                    section: 'grammarly',
                })),
            };
            const override = config.overrides.find((override) => toArray(override.files).some((pattern) => minimatch(uri, pattern)));
            const settings = {
                audience: config.audience,
                dialect: config.dialect,
                domain: config.domain,
                emotions: config.emotions,
                goals: config.goals,
                style: config.style,
                ...override === null || override === void 0 ? void 0 : override.config,
            };
            this.perDocumentSettings.set(uri, settings);
            this.wip.delete(uri);
            return settings;
        };
        const promise = get();
        this.wip.set(uri, promise);
        return promise;
    }
    isIgnoredDocument(uri) {
        return toArray(this.user.ignore).some((pattern) => minimatch(uri, pattern));
    }
};
ConfigurationService = __decorate([
    injectable(),
    __param(0, inject(CONNECTION)),
    __metadata("design:paramtypes", [Object])
], ConfigurationService);

let DictionaryService = class DictionaryService {
    constructor(configuration) {
        this.configuration = configuration;
    }
    register() {
        return Disposable.create(() => { });
    }
    isKnownWord(word) {
        const words = this.configuration.settings.userWords;
        return words.includes(word) || words.includes(word.toLocaleLowerCase());
    }
};
DictionaryService = __decorate([
    injectable(),
    __metadata("design:paramtypes", [ConfigurationService])
], DictionaryService);

const parser = remark();
function parse(content) {
    const ast = parser.parse(content);
    const tree = new IntervalTree();
    iterate(ast, node => {
        const { type, position } = node;
        if (position) {
            tree.insert([position.start.offset, position.end.offset], type);
        }
    });
    return (interval) => tree.search(interval);
}
function iterate(node, fn) {
    const queue = [node];
    fn(node);
    while (queue.length) {
        const node = queue.shift();
        node.children.forEach(node => {
            fn(node);
            if (Array.isArray(node.children)) {
                queue.push(node);
            }
        });
    }
}

var markdown = /*#__PURE__*/Object.freeze({
    __proto__: null,
    parse: parse
});

const parsers = {
    markdown,
};

class GrammarlyDocument {
    constructor(internal) {
        this.internal = internal;
        this._host = null;
        this.isDirty = true;
    }
    attachHost(factory) {
        this.detachHost();
        this._host = factory.create(this);
    }
    detachHost() {
        if (this._host) {
            this._host.dispose();
            this._host = null;
        }
    }
    inIgnoredRange(interval, tags) {
        if (this.isDirty) {
            this.isDirty = false;
            const parser = parsers[this.languageId];
            try {
                if (parser)
                    this.rangeToIdentifierFn = parser.parse(this.getText());
            }
            catch { }
        }
        if (this.rangeToIdentifierFn) {
            const matched = new Set(this.rangeToIdentifierFn(interval));
            return tags.some((tag) => matched.has(tag));
        }
        return false;
    }
    get host() {
        return this._host;
    }
    get uri() {
        return this.internal.uri;
    }
    get languageId() {
        return this.internal.languageId;
    }
    get version() {
        return this.internal.version;
    }
    getText(range) {
        return this.internal.getText(range);
    }
    positionAt(offset) {
        return this.internal.positionAt(offset);
    }
    rangeAt(start, end) {
        return { start: this.positionAt(start), end: this.positionAt(end) };
    }
    offsetAt(position) {
        return this.internal.offsetAt(position);
    }
    get lineCount() {
        return this.internal.lineCount;
    }
    static create(uri, languageId, version, content) {
        return new GrammarlyDocument(TextDocument.create(uri, languageId, version, content));
    }
    static update(document, changes, version) {
        document.isDirty = true;
        if (document._host) {
            const editor = document._host.edit(document.internal.getText().length, version);
            changes.forEach((change) => {
                if ('range' in change) {
                    const start = document.offsetAt(change.range.start);
                    const end = document.offsetAt(change.range.end);
                    const deleteLength = end - start;
                    if (deleteLength) {
                        editor.deleteText(start, deleteLength);
                        if (change.text.length)
                            editor.setText(change.text);
                    }
                    else if (change.text.length) {
                        editor.insertText(start, change.text);
                    }
                }
                else {
                    editor.setText(change.text);
                }
                editor.commit();
            });
            editor.commit().apply();
        }
        document.internal = TextDocument.update(document.internal, changes, version);
        return document;
    }
}

function isString(value) {
    return typeof value === 'string';
}
function isError(value) {
    return value instanceof Error;
}
class DevLogger {
    constructor(name, defaultContext = '') {
        this.name = name;
        this.defaultContext = defaultContext;
    }
    trace(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    debug(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    info(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    warn(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    error(...args) {
        this.write("TRACE" /* TRACE */, args);
    }
    write(level, args) {
        if (level >= DevLogger.options.level &&
            (DevLogger.options.enabled.has('*') || DevLogger.options.enabled.has(this.name))) {
            const context = args.length >= 2 && isString(args[0]) && (isString(args[1]) || isError(args[1]))
                ? args.shift()
                : this.defaultContext;
            const message = `${Date.now()} ${level}  [${this.name}]${context ? ' (' + context + ')' : ''} ${this.inspect(args)}`;
            switch (level) {
                case "ERROR" /* ERROR */:
                    console.error(message);
                    break;
                case "WARN" /* WARN */:
                    console.warn(message);
                    break;
                default:
                    console.log(message);
                    break;
            }
        }
    }
    inspect(args) {
        return args.map((arg) => (typeof arg === 'object' && arg ? inspect(arg, true, null) : arg)).join(' ');
    }
}
DevLogger.options = {
    enabled: new Set(['*']),
    level: "TRACE" /* TRACE */,
};

class TextGrammarCheckHost {
    constructor(document, getDocumentContext, getTokenInfo, onError) {
        var _a;
        this.document = document;
        this.getDocumentContext = getDocumentContext;
        this.getTokenInfo = getTokenInfo;
        this.onError = onError;
        this.offsetVersion = 0;
        this.events = new EventEmitter({ captureRejections: true });
        this.auth = null;
        this.alerts = ref(new Map());
        this.user = ref({ isAnonymous: true, isPremium: false });
        this.score = ref(-1);
        this.generalScore = ref(-1);
        this.status = ref('CHECKING');
        this.scores = ref({});
        this.emotions = ref([]);
        this.textInfo = ref(null);
        this.disposables = [];
        this.id = Buffer.from(this.document.uri).toString('hex');
        this.LOGGER = process.env.NODE_ENV !== 'production' ? new DevLogger(TextGrammarCheckHost.name, this.id) : null;
        this.api = new GrammarlyClient({
            clientName: 'unofficial-grammarly-language-server',
            clientType: 'general',
            documentId: this.id,
            getToken: async () => {
                this.auth = await this.getTokenInfo();
                return this.auth.token;
            },
            onConnection: async () => {
                const context = await this.getDocumentContext();
                this.offsetVersion = this.document.version;
                await this.api.start({ documentContext: context, dialect: context.dialect });
                await this.api.setOption({
                    name: 'gnar_containerId',
                    value: this.auth.container,
                });
                await this.edit(0).setText(this.document.getText()).apply();
            },
            onMessage: (message) => this.events.emit(message.action, message),
            onError: (error) => {
                this.onError(error);
                if (error instanceof SocketError) {
                    if (error.code === 4000) {
                        this.api.ping();
                    }
                }
            },
        });
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.debug(`Hosting ${document.uri}`);
        this.on(ResponseKind.ALERT, (alert) => this.alerts.value.set(alert.id, alert));
        this.on(ResponseKind.REMOVE, (alert) => this.alerts.value.delete(alert.id));
        this.on(ResponseKind.SUBMIT_OT, (message) => {
            var _a;
            this.remoteRevision = message.rev;
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`Local: ${this.getLocalRevision()}, Remote: ${this.remoteRevision}, Version: ${this.document.version}`);
        });
        this.on(ResponseKind.EMOTIONS, (message) => {
            this.emotions.value = message.emotions;
        });
        this.on(ResponseKind.FINISHED, (message) => {
            this.status.value = 'IDLE';
            if (message.outcomeScores) {
                this.scores.value = message.outcomeScores;
            }
            this.score.value = message.score;
            if (message.generalScore) {
                this.generalScore.value = message.generalScore;
            }
        });
        this.on(ResponseKind.TEXT_INFO, (message) => {
            this.textInfo.value = message;
        });
        this.on(ResponseKind.TEXT_INFO, (message) => {
            this.textInfo.value = message;
        });
    }
    get context() {
        return this.auth || { username: 'anonymous', isAnonymous: true, container: '' }; // TODO: Get user info from API.
    }
    on(action, callback) {
        this.events.on(action, callback);
        return () => this.off(action, callback);
    }
    off(action, callback) {
        this.events.off(action, callback);
    }
    once(action, callback) {
        this.events.once(action, callback);
    }
    onTextChange(callback) {
        this.events.on('change', callback);
        return () => this.events.off('change', callback);
    }
    getLocalRevision(version = this.document.version) {
        return (version - this.offsetVersion);
    }
    onDispose(fn) {
        this.disposables.push(fn);
    }
    dispose() {
        this.disposables.forEach((dispose) => {
            try {
                dispose();
            }
            catch { }
        });
        this.api.dispose();
        this.events.removeAllListeners();
    }
    edit(doc_len = this.document.getText().length, nextVersion) {
        const rev = this.getLocalRevision(nextVersion);
        return new ChangeSet(async (deltas, changes) => {
            var _a;
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`Local: ${rev}, Remote: ${this.remoteRevision}, Version: ${this.document.version}`);
            this.events.emit('change', { rev, changes });
            this.status.value = 'CHECKING';
            await this.api.submitOT({ rev, doc_len, deltas, chunked: false });
        });
    }
    async getSynonyms(offset, word) {
        const result = await this.api.getSynonyms({ begin: offset, token: word });
        return result.synonyms;
    }
    async getTextStats() {
        return this.api.getTextStats({});
    }
    getAlert(id) {
        return this.alerts.value.get(id);
    }
    async addToDictionary(_) {
        // TODO
    }
    async dismissAlert(_) {
        // TODO
    }
    async acceptAlert(alertId, text) {
        this.api.sendFeedbackForAlert({ type: 'ACCEPTED', text, alertId });
    }
    async setDocumentContext(documentContext) {
        await this.api.setContext({ rev: 1, documentContext });
    }
}

class GrammarlyHostFactory {
    constructor(getDocumentContext, getCredentials, storeToken) {
        this.getDocumentContext = getDocumentContext;
        this.getCredentials = getCredentials;
        this.storeToken = storeToken;
        this.auth = null;
    }
    create(document) {
        const host = new TextGrammarCheckHost(document, () => this.getDocumentContext(document), () => this.getAuth(), (error) => {
            if (error instanceof SocketError) {
                if (error.code === SocketErrorCode.UNAUTHORIZED) {
                    this.auth = null;
                    // @ts-ignore - accessing private property.
                    host.api.reconnect();
                }
            }
        });
        return host;
    }
    async getAuth() {
        if (!this.auth) {
            try {
                this.auth = await this.asUser();
            }
            catch {
                // Ignore for now.
            }
        }
        return this.auth || this.asAnonymous();
    }
    async asAnonymous() {
        return (this.auth = await anonymous());
    }
    async asUser() {
        const credentials = await this.getCredentials();
        if (typeof credentials === 'string') {
            return JSON.parse(credentials);
        }
        else if (credentials) {
            this.auth = await authenticate(credentials.username, credentials.password);
            if (this.auth)
                this.storeToken(JSON.stringify(this.auth));
        }
    }
}

let DocumentService = class DocumentService {
    constructor(connection, capabilities, configuration) {
        this.connection = connection;
        this.capabilities = capabilities;
        this.configuration = configuration;
        this.documents = new TextDocuments(GrammarlyDocument);
        this.hostFactory = new GrammarlyHostFactory(async (document) => this.configuration.getDocumentSettings(document.uri), async () => this.getCredentials(), async (token) => this.connection.sendRequest('$/storeToken', { token }));
        this.onDocumentOpenCbs = [];
        this.onDocumentCloseCbs = [];
    }
    register() {
        this.capabilities.textDocumentSync = {
            openClose: true,
            change: TextDocumentSyncKind.Incremental,
        };
        this.documents.listen(this.connection);
        const disposables = [
            this.documents.onDidOpen(({ document }) => this.attachHost(document)),
            this.documents.onDidClose(({ document }) => this.handleClose(document)),
            Disposable.create(() => this.documents.all().forEach((document) => document.detachHost())),
        ];
        return Disposable.create(() => disposables.forEach((disposable) => disposable.dispose()));
    }
    get(uri) {
        return this.documents.get(uri);
    }
    onDidOpen(fn) {
        this.onDocumentOpenCbs.push(fn);
    }
    onDidClose(fn) {
        this.onDocumentCloseCbs.push(fn);
    }
    async attachHost(document, force = false) {
        if (!this.configuration.settings.autoActivate && !force)
            return;
        document.attachHost(this.hostFactory);
        this.onDocumentOpenCbs.forEach((cb) => cb(document));
    }
    async getCredentials() {
        try {
            const result = await this.connection.sendRequest('$/token');
            if (result)
                return result.token;
        }
        catch { }
        return this.connection.sendRequest('$/credentials');
    }
    async handleClose(document) {
        this.onDocumentCloseCbs.forEach((cb) => cb(document));
        document.detachHost();
    }
};
DocumentService = __decorate([
    injectable(),
    __param(0, inject(CONNECTION)),
    __param(1, inject(SERVER)),
    __metadata("design:paramtypes", [Object, Object, ConfigurationService])
], DocumentService);

function isNumber(value) {
    return typeof value === 'number';
}

var GrammarlyLanguageServer;
(function (GrammarlyLanguageServer) {
    GrammarlyLanguageServer.Feature = {
        stop: '$/stop',
        checkGrammar: '$/checkGrammar',
        acceptAlert: '$/feedbackAcceptAlert',
        getDocumentState: '$/getDocumentState',
    };
    let Client;
    (function (Client) {
        Client.Feature = {
            getCredentials: '$/getCredentials',
            updateDocumentState: '$/updateDocumentState',
        };
    })(Client = GrammarlyLanguageServer.Client || (GrammarlyLanguageServer.Client = {}));
})(GrammarlyLanguageServer || (GrammarlyLanguageServer = {}));

const INITIAL_WATCHER_VALUE = {};
function watch(ref, cb) {
    const getter = () => traverse(ref.value);
    let oldValue = INITIAL_WATCHER_VALUE;
    const job = () => {
        const newValue = runner();
        try {
            cb(newValue, oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue);
        }
        catch (error) {
            console.error(error);
        }
        oldValue = newValue;
    };
    const runner = effect(getter, {
        lazy: true,
        scheduler: job,
    });
    job();
    return () => {
        stop(runner);
    };
}
function watchEffect(cb) {
    const runner = effect(cb, { lazy: true });
    runner();
    return () => {
        stop(runner);
    };
}
function traverse(value, seen = new Set()) {
    if (!isObject(value) || seen.has(value)) {
        return value;
    }
    seen.add(value);
    if (isRef(value)) {
        traverse(value.value, seen);
    }
    else if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if (value instanceof Map) {
        value.forEach((_, key) => {
            // to register mutation dep for existing keys
            traverse(value.get(key), seen);
        });
    }
    else if (value instanceof Set) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}
function isObject(value) {
    return typeof value === 'object' && value !== null;
}

var GrammarlyDiagnosticsService_1;
const SOURCE = 'Grammarly';
let GrammarlyDiagnosticsService = GrammarlyDiagnosticsService_1 = class GrammarlyDiagnosticsService {
    constructor(connection, capabilities, documents, config) {
        this.connection = connection;
        this.capabilities = capabilities;
        this.documents = documents;
        this.config = config;
        this.LOGGER = new DevLogger(GrammarlyDiagnosticsService_1.name);
        this.diagnostics = new Map();
        this.histories = new Map();
    }
    register() {
        this.capabilities.hoverProvider = true;
        this.capabilities.codeActionProvider = true;
        this.connection.onRequest(GrammarlyLanguageServer.Feature.checkGrammar, (ref) => {
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.checkGrammar}(${JSON.stringify(ref, null, 2)})`);
            this.check(ref.uri);
        });
        this.connection.onRequest(GrammarlyLanguageServer.Feature.stop, (ref) => {
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.stop}(${JSON.stringify(ref, null, 2)})`);
            const document = this.documents.get(ref.uri);
            if (document != null) {
                this.clearDiagnostics(document);
                this.connection.sendRequest(GrammarlyLanguageServer.Client.Feature.updateDocumentState, { uri: document.uri });
                document.detachHost();
            }
        });
        this.connection.onRequest(GrammarlyLanguageServer.Feature.getDocumentState, (ref) => {
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.checkGrammar}(${JSON.stringify(ref, null, 2)})`);
            const document = this.documents.get(ref.uri);
            if (document === null || document === void 0 ? void 0 : document.host) {
                return this.getDocumentState(document);
            }
            return null;
        });
        this.connection.onRequest(GrammarlyLanguageServer.Feature.acceptAlert, (options) => {
            var _a;
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.acceptAlert}(${JSON.stringify(options, null, 2)})`);
            const document = this.documents.get(options.uri);
            (_a = this.diagnostics.get(options.uri)) === null || _a === void 0 ? void 0 : _a.delete(options.id);
            if (document === null || document === void 0 ? void 0 : document.host) {
                document.host.acceptAlert(options.id, options.text);
                this.sendDiagnostics(document);
            }
        });
        this.documents.onDidOpen((document) => {
            if (document.host) {
                this.LOGGER.trace(`Listening Grammarly alerts for ${document.uri}`);
                this.setupDiagnostics(document);
            }
        });
        this.documents.onDidClose((document) => {
            this.LOGGER.trace(`Stopping Grammarly alerts for ${document.uri}`);
            this.clearDiagnostics(document);
        });
        this.connection.onHover(({ position, textDocument }) => {
            this.LOGGER.trace('Hover', `Incoming request for ${textDocument.uri} at`, position);
            const diagnostics = this.findDiagnosticsAt(textDocument.uri, position);
            this.LOGGER.debug('Hover', 'Active diagnostics at', diagnostics);
            const document = this.documents.get(textDocument.uri);
            if (!diagnostics.length)
                return null;
            const range = document.rangeAt(Math.min(...diagnostics.map((diagnostic) => diagnostic.start)), Math.max(...diagnostics.map((diagnostic) => diagnostic.end)));
            const hover = {
                range: range,
                contents: [],
            };
            const config = {
                isDebugMode: this.config.settings.debug,
                showDetails: this.config.settings.showExplanation,
                showExamples: this.config.settings.showExamples,
                cta: document.host.user.value.isAnonymous
                    ? '> 👉 [Login](https://www.grammarly.com/upgrade) to get automated fix for this issue.'
                    : document.host.user.value.isPremium
                        ? ''
                        : '> ⏫ [Upgrade](https://www.grammarly.com/upgrade) to get automated fix for this issue.',
            };
            unique(diagnostics.map((diagnostic) => diagnostic.id))
                .map((id) => document.host.getAlert(id))
                .forEach((alert, index) => {
                var _a;
                if (!alert)
                    return;
                if (alert.title) {
                    const hasFixes = alert.replacements.length;
                    hover.contents.push(toMarkdown(`#### ${alert.title}`, index === 0 ? (hasFixes ? `` : config.cta) : '', alert.explanation, config.showDetails && !alert.hidden ? alert.details : '', config.showExamples && !alert.hidden ? alert.examples : ''));
                }
                else if ((_a = alert.subalerts) === null || _a === void 0 ? void 0 : _a.length) {
                    const hasFixes = alert.subalerts.every((alert) => !!alert.transformJson.alternatives);
                    const count = alert.subalerts.length;
                    hover.contents.push(toMarkdown(`### ${alert.cardLayout.outcome}`, index === 0 ? (hasFixes ? `` : config.cta) : '', alert.cardLayout.outcomeDescription, '<p></p>', `*There ${count > 1 ? 'are' : 'is'} ${count} such ${count > 1 ? 'issues' : 'issue'} in this document.*`));
                }
                else {
                    const hasFixes = alert.replacements.length;
                    hover.contents.push(toMarkdown(`### ${alert.cardLayout.outcome}`, index === 0 ? (hasFixes ? `` : config.cta) : '', alert.cardLayout.outcomeDescription));
                }
                if (config.isDebugMode) {
                    hover.contents.push({ value: JSON.stringify(alert, null, 2), language: 'json' });
                }
            });
            this.LOGGER.debug('Hover', 'Sending', hover);
            return hover;
        });
        this.connection.onCodeAction(async ({ textDocument, context }) => {
            const document = this.documents.get(textDocument.uri);
            const diagnostics = context.diagnostics.filter((diagnostic) => diagnostic.source === SOURCE);
            this.LOGGER.trace(`CodeAction in ${textDocument.uri}`, diagnostics);
            const actions = [];
            if (diagnostics.length === 1 && (document === null || document === void 0 ? void 0 : document.host)) {
                const diagnostic = diagnostics[0];
                const alert = document.host.getAlert(diagnostic.code);
                if (alert && alert.replacements.length) {
                    const range = rebaseTextRange({ start: alert.begin, end: alert.end }, this.findChangesSinceRevision(document, alert.rev));
                    this.LOGGER.debug('Changes since', alert.rev, this.findChangesSinceRevision(document, alert.rev), this.histories.get(document.uri));
                    const newRange = document.rangeAt(range.start, range.end);
                    alert.replacements.forEach((newText) => {
                        actions.push({
                            title: alert.minicardTitle,
                            kind: CodeActionKind.QuickFix,
                            diagnostics: diagnostics,
                            isPreferred: true,
                            command: {
                                command: 'grammarly.callback',
                                title: '',
                                arguments: [
                                    {
                                        method: GrammarlyLanguageServer.Feature.acceptAlert,
                                        params: { id: alert.id, text: newText, uri: textDocument.uri },
                                    },
                                ],
                            },
                            edit: {
                                changes: {
                                    [textDocument.uri]: [
                                        {
                                            range: newRange,
                                            newText: newText,
                                        },
                                    ],
                                },
                            },
                        });
                    });
                }
            }
            // TODO: Provide synonyms.
            this.LOGGER.debug('Providing code actions', actions);
            return actions;
        });
        this.LOGGER.trace('Registering diagnostics service for Grammarly');
        return Disposable.create(() => { });
    }
    findDiagnosticsAt(uri, position) {
        const document = this.documents.get(uri);
        const diagnostics = this.diagnostics.get(uri);
        if (!document || !document.host || !diagnostics) {
            return [];
        }
        const offset = document.offsetAt(position);
        return Array.from(diagnostics.values())
            .flat()
            .filter((diagnostic) => diagnostic.start <= offset && offset <= diagnostic.end);
    }
    async check(uri) {
        const document = this.documents.get(uri);
        if (document) {
            // When host is attached onDidOpen callback would be called.
            await this.documents.attachHost(document, true);
        }
    }
    setupDiagnostics(document) {
        this.diagnostics.set(document.uri, new Map());
        this.histories.set(document.uri, []);
        const diagnostics = this.diagnostics.get(document.uri);
        const history = this.histories.get(document.uri);
        document.host.onDispose(watch(document.host.alerts, (alerts) => {
            let shouldSend = false;
            alerts.forEach((alert) => {
                const diagnostic = diagnostics.get(alert.id);
                if (diagnostic === null || diagnostic === void 0 ? void 0 : diagnostic.length) {
                    if (diagnostic.some((d) => d.id === alert.id))
                        return;
                }
                this.LOGGER.trace(`${diagnostic ? 'Update' : 'Add'}: ${alert.id} for ${document.uri}`);
                shouldSend = true;
                diagnostics.set(alert.id, this.toDiagnostics(alert, document).map((diagnostic) => this.rebaseWithHistory(document, diagnostic, alert.rev)));
            });
            if (shouldSend)
                this.sendDiagnostics(document, true);
        }));
        document.host.onDispose(watchEffect(() => this.sendDocumentState(document)));
        // Clear stale revision history.
        document.host.on(ResponseKind.SUBMIT_OT, (message) => {
            const history = this.histories.get(document.uri);
            if (history && history.length > 150) {
                this.LOGGER.trace(`CleanHistory: v${document.version} rev${message.rev} ${document.uri}`);
                this.histories.set(document.uri, history.slice(history.length - 100));
            }
        });
        document.host.on(ResponseKind.FINISHED, () => {
            this.sendDiagnostics(document);
        });
        // Repositions diagnostics as text changes.
        document.host.onTextChange((message) => {
            this.LOGGER.trace(`Rebase: v${document.version} -> rev${message.rev} ${document.uri}`);
            history.push(message);
            diagnostics.forEach((diagnostics) => {
                diagnostics.forEach((diagnostic) => {
                    this.rebaseWithChanges(document, diagnostic, message.changes);
                });
            });
            this.sendDiagnostics(document);
        });
        this.sendDiagnostics(document);
    }
    sendDocumentState(document) {
        this.connection.sendRequest(GrammarlyLanguageServer.Client.Feature.updateDocumentState, this.getDocumentState(document));
    }
    getDocumentState(document) {
        let additionalFixableErrors = 0;
        let premiumErrors = 0;
        document.host.alerts.value.forEach((error) => {
            if (!error.free)
                ++premiumErrors;
            else if (error.hidden)
                ++additionalFixableErrors;
        });
        return {
            uri: document.uri,
            score: document.host.score.value,
            status: document.host.status.value,
            scores: document.host.scores.value,
            emotions: document.host.emotions.value,
            textInfo: document.host.textInfo.value,
            totalAlertsCount: document.host.alerts.value.size,
            additionalFixableAlertsCount: additionalFixableErrors,
            premiumAlertsCount: premiumErrors,
            user: document.host.user.value,
        };
    }
    rebaseWithChanges(document, diagnostic, changes) {
        const range = rebaseTextRange(diagnostic, changes);
        diagnostic.start = range.start;
        diagnostic.end = range.end;
        diagnostic.range = document.rangeAt(range.start, range.end);
        return diagnostic;
    }
    rebaseWithHistory(document, diagnostic, rev) {
        const changes = this.findChangesSinceRevision(document, rev);
        return this.rebaseWithChanges(document, diagnostic, changes);
    }
    findChangesSinceRevision(document, rev) {
        return this.findHistorySinceRevision(document, rev)
            .map((history) => history.changes)
            .flat();
    }
    findHistorySinceRevision(document, rev, inclusive = false) {
        const history = this.histories.get(document.uri);
        if (history) {
            const index = history.findIndex((event) => event.rev === rev);
            if (index >= 0) {
                if (inclusive)
                    return history.slice(index);
                else
                    return history.slice(index + 1);
            }
        }
        return [];
    }
    toDiagnostics(alert, document) {
        const diagnostics = [];
        if (this.config.settings.hideUnavailablePremiumAlerts && alert.hidden) {
            return [];
        }
        const severity = getAlertSeverity(alert);
        if (isNumber(alert.begin) && isNumber(alert.end)) {
            if (!alert.title) {
                this.LOGGER.warn('toDiagnostics', `Missing title`, alert);
            }
            diagnostics.push({
                id: alert.id,
                code: alert.id,
                message: toText(alert.title || alert.categoryHuman),
                range: document.rangeAt(alert.highlightBegin, alert.highlightEnd),
                source: SOURCE,
                severity: severity,
                tags: severity === DiagnosticSeverity.Hint ? [DiagnosticTag.Unnecessary] : [],
                rev: alert.rev,
                start: alert.highlightBegin,
                end: alert.highlightEnd,
            });
        }
        else if (alert.subalerts) {
            const relatedInformation = [];
            alert.subalerts.forEach((subalert) => {
                const { s: start, e: end } = subalert.transformJson.context;
                subalert.transformJson.highlights.forEach((highlight) => {
                    const highlightBegin = start + highlight.s;
                    const highlightEnd = start + highlight.e;
                    const range = document.rangeAt(highlightBegin, highlightEnd);
                    const message = toText(alert.title || alert.categoryHuman);
                    relatedInformation.push({ location: { uri: document.uri, range }, message: subalert.highlightText });
                    diagnostics.push({
                        id: alert.id,
                        code: alert.id,
                        message,
                        range,
                        source: SOURCE,
                        severity: severity,
                        relatedInformation,
                        rev: alert.rev,
                        start: highlightBegin,
                        end: highlightEnd,
                    });
                });
            });
        }
        else {
            this.LOGGER.warn('toDiagnostics', `Unhandled alert`, alert);
        }
        return diagnostics;
    }
    clearDiagnostics(document) {
        this.connection.sendDiagnostics({ uri: document.uri, version: document.version, diagnostics: [] });
    }
    sendDiagnostics(document, ignoreVersion = false) {
        var _a;
        const diagnostics = Array.from(((_a = this.diagnostics.get(document.uri)) === null || _a === void 0 ? void 0 : _a.values()) || []).flat();
        this.LOGGER.debug(`Diagnostics: Sending ${diagnostics.length} alerts`, diagnostics);
        if (ignoreVersion) {
            this.connection.sendDiagnostics({ uri: document.uri, diagnostics: diagnostics });
        }
        else {
            this.connection.sendDiagnostics({ uri: document.uri, version: document.version, diagnostics: diagnostics });
        }
    }
};
GrammarlyDiagnosticsService = GrammarlyDiagnosticsService_1 = __decorate([
    injectable(),
    __param(0, inject(CONNECTION)),
    __param(1, inject(SERVER)),
    __metadata("design:paramtypes", [Object, Object, DocumentService,
        ConfigurationService])
], GrammarlyDiagnosticsService);
function toText(...html) {
    return html
        .filter((value) => typeof value === 'string')
        .join('\n\n')
        .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
        .replace(/<p>/gi, '\n\n') // Explanation has unclosed <p> tag.)
        .replace(/<br\/>/gi, '  \n')
        .replace(/<[a-z][^/>]*?\/?>/gi, '')
        .replace(/<\/[a-z][^>]*?>/gi, '')
        .replace(/\n{3,}/g, '\n\n') // Remove unnecessary empty lines.
        .trim();
}
function toMarkdown(...html) {
    return html
        .filter((value) => typeof value === 'string')
        .join('\n\n')
        .replace(/<b>(.*?)<\/b>/gi, '**$1**')
        .replace(/<i>(.*?)<\/i>/gi, '*$1*')
        .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
        .replace(/<p>/gi, '\n\n') // Explanation has unclosed <p> tag.)
        .replace(/<br\/>/gi, '  \n')
        .replace(/<span class="red">/gi, '❌ <span style="color:#FF0000">')
        .replace(/<span class="green">/gi, '✅ <span style="color:#00FF00">')
        .replace(/\n{3,}/g, '\n\n') // Remove unnecessary empty lines.
        .trim();
}
function unique(items) {
    return Array.from(new Set(items));
}
function getAlertSeverity(alert) {
    if (alert.impact === 'critical')
        return DiagnosticSeverity.Error;
    switch (alert.cardLayout.outcome.toLowerCase()) {
        case 'clarity':
        case 'engagement':
            return DiagnosticSeverity.Information;
        case 'tone':
            return DiagnosticSeverity.Warning;
        case 'vox':
            return DiagnosticSeverity.Hint;
        case 'correctness':
        case 'other':
        default:
            return DiagnosticSeverity.Error;
    }
}

function startLanguageServer() {
    const disposables = [];
    const capabilities = {};
    const container = new Container({
        autoBindInjectable: true,
        defaultScope: 'Singleton',
    });
    const connection = createConnection(ProposedFeatures.all);
    container.bind(CONNECTION).toConstantValue(connection);
    container.bind(SERVER).toConstantValue(capabilities);
    connection.onInitialize((params) => {
        container.bind(CLIENT).toConstantValue(params.capabilities);
        disposables.push(container.get(ConfigurationService).register(), container.get(DocumentService).register(), container.get(DictionaryService).register(), container.get(GrammarlyDiagnosticsService).register());
        return {
            serverInfo: {
                name: 'Grammarly',
            },
            capabilities,
        };
    });
    connection.onExit(() => {
        disposables.forEach((disposable) => disposable.dispose());
    });
    connection.listen();
}

export { GrammarlyLanguageServer, startLanguageServer };
//# sourceMappingURL=index.esm.js.map
